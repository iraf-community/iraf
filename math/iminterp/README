Image interpolation package.  Contains interpolator routines specially
designed to interpolate image data.  This interpolator task is characterized
by data arrays in which the data points are equally spaced.  Data points
and interpolation points are referenced simply by array index.  Indefinite
valued pixels may not be present in the data.  Since the interpolation routines
will be applied to very large data arrays, efficiency is emphasized in these
routines.

------------------------------------------------------------------------------
The following are some notes on the 1D sinc interpolation algorithm.
These notes are only for the interpolation evaluation and does not cover
the derivatives.

Sinc interpolation consists of weighting the pixel data by the sinc function
centered on the desired interpolation point.

Define	z = pi * (x - xi) = pi * (x - x0 - i) = pi * (dx - i)
	s = sin (z) = (-1)**i * sin (z0) = (-1)**i * s0
	w = s / z = (-1)**i * s0 / z
	I = sum (Ii * w) / sum (w) = u / v

where i can be both positive and negative, dx is the distance to the
nearest pixel center, x0, from x, and w is the sinc function weight.
Note that the interpolation for I is a ratio in which both the pi
and s0 factors cancel.  Thus, the interpolation does not need to use
pi or evaluate any trig functions.  So:

	z = 1 / (dx - i)
	u = sum (Ii * z * (-1)**i)
	v = sum (z * (-1)**i)
	I = u / v

where z is now defined as the reciprical as used in the code.

In principle one must take the sums over all pixels for each desired
interpolation position x.  However, in practice it is enough to
carry the sum over a certain window distance.  At the end of the window
a taper is applied.  While a cosine bell taper might be desireable
the code uses a linear taper to zero for efficiency.  It was found
by experiment that the taper was not really important.

The averaging of two interpolations differing in the width of the
window by one pixel was found to give much better results because
a small odd/even endpoint effect was smoothed out.

The testing consisted of interpolating a vector by a fractional amount,
say 0.4-0.5, in one direction and then interpolating the result back
by the opposite amount.  The difference with the original vector shows
residuals typically 10 times smaller than the same test with polynomial
interpolators.



