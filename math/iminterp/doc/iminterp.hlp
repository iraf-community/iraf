.help iminterp Aug84 "Math Package"
.ih
NAME
iminterp -- image interpolator package
.ih
SYNOPSIS

.nf
         asiinit (asi, interp_type)
          asifit (asi, datain, npix)
ivalue = asigeti (asi, param)
     y = asieval (asi, x)
       asivector (asi, x, yfit, npix)
          asider (asi, x, der, nder)
      v = asigrl (asi, a, b)
         asisave (asi, interpolant)
      asirestore (asi, interpolant)
         asifree (asi)

     y = arieval (x, datain, npix, interp_type)
	  arider (x, datain, npix, der, nder, interp_type)

          arbpix (datain, dataout, npix, interp_type, boundary_type)
.fi

.nf
         msiinit (msi, interp_type)
          msifit (msi, datain, nxpix, nypix, len_datain)
ivalue = msigeti (msi, param)
     y = msieval (msi, x, y)
       msivector (msi, x, y, zfit, npts)
          msider (msi, x, y, der, nxder, nyder, len_der)
      v = msigrl (msi, x, y, npts)
    v = msisqgrl (msi, x1, x2, y1, y2)
         msisave (msi, interpolant)
      msirestore (msi, interpolant)
         msifree (msi)

      y = mrieval (x, y, datain, nxpix, nypix, len_dataina, interp_type)
           mrider (x, y, datain, nxpix, nypix, len_datain, der, nxder, nyder,
	           len_der, interp_type)
.fi

.ih
DESCRIPTION
The iminterp package provides a set of routines for interpolating uniformly
spaced data assuming that the spacing between data points is 1.0. The
package is divided into 1D and 2D array sequential interpolants,
prefixes asi and msi, and 1D and 2D
array random interpolants, prefixes ari and mri.
The sequential interpolants have
been optimized for returning many values as is the case when an array is
shifted. The random interpolants allow evaluation of a few interpolated
points without the computing time and storage overhead required for
setting up the sequential version.
.ih
NOTES
The interpolant is chosen at run time from the following list.

.nf
    II_NEAREST		# nearest neighbour in x
    II_LINEAR		# linear interpolation in x
    II_POLY3		# 3rd order interior polynomial in x
    II_POLY5		# fifth order interior polynomial in x
    II_SPLINE3		# cubic spline in x
    II_SINC		# sinc interpolation in x

    II_BINEAREST	# nearest neighbour in x and y
    II_BILINEAR		# bilinear interpolation
    II_BIPOLY3		# 3rd order interior polynomial in x and y
    II_BIPOLY5		# 5th order interior polynomial in x and y
    II_BISPLINE3	# bicubic spline
.fi

The routines assume that all x (1D, 2D) and  y (2D) values of interest lie in
the region
1 <= x <= nxpix, 1 <= y <= nypix.
Checking for out of bounds x and/or y values is the responsibility
of the calling program. The asi, ari, msi, and mri routines assume that INDEF
valued pixels have been removed from the data prior to entering the
package. The routine ARBPIX has been added to the package to facilitate
INDEF valued pixel removal.

In order to make the package definitions available to the calling program
an include <math/iminterp.h> statement must appear in the calling program.
Either ASIINIT or ASIRESTORE  must be called before using the asi routines.
ASIFREE frees the space used by the asi routines. For the msi routines the
corresponding examples are MSIINIT, MSIRESTORE and MSIFREE.
.ih
EXAMPLES
.nf
Example 1: Shift a 1D data array by a constant amount

    include <math/iminterp.h>
    ...
    call asiinit (asi, II_POLY5)
    call asifit (asi, inrow, npix)

    do i = 1, npix
	outrow[i] = asieval (asi, i + xshift)

    call asifree (asi)
    ...

Example 2: Shift a 2D array by a constant amount

    include <math/iminterp.h>
    ...
    call msiinit (msi, II_BIPOLY3)
    call msifit (msi, insection, nxpix, nypix, nxpix)

    do j = 1, nypix
	do i = 1, nxpix
	    outsection[i,j] = msieval (msi, i + xshift, j + yshift)

    call msifree (msi)
    ...

Example 3: Calculate the integral under a 1D data array

    include <math/iminterp.h>
    ...
    call asiinit (asi, II_POLY5)
    call asifit (asi, datain, npix)

    integral =  asigrl (asi, 1. real (npix))

    call asifree (asi)
    ...

Example 4: Store a 1D interpolant for later use by ASIEVAL

    include <math/iminterp.h>

    ...
    call asiinit (asi, II_POLY3)
    call asifit (asi, datain, npix)

    len_interpolant = asigeti (asi, ASINSAVE)
    call salloc (interpolant, len_interpolant, TY_REAL)
    call asisave (asi, Memr[interpolant])

    call asifree (asi)
    ...
    call asirestore (asi, Memr[interpolant])

    do i = 1, npts
	yfit[i] = asieval (asi, x[i])

    call asifree (asi)
    ...
.fi
.endhelp
