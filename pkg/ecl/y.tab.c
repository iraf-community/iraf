#ifndef lint
static char const 
yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
#endif
#include <stdlib.h>
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYLEX yylex()
#define YYEMPTY -1
#define yyclearin (yychar=(YYEMPTY))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING() (yyerrflag!=0)
static int yygrowstack();
#define YYPREFIX "yy"
#line 2 "grammar.y"

#define import_spp
#define import_libc
#define import_stdio
#define import_ctype
#include <iraf.h>

#include "config.h"
#include "mem.h"
#include "operand.h"
#include "param.h"
#include "grammar.h"
#include "opcodes.h"
#include "clmodes.h"
#include "task.h"
#include "construct.h"
#include "errs.h"


/* CL parser, written as a yacc grammar:
 *   build up an (rpn) instruction sequence begining at the base of the
 *   operand stack as the grammar is recognized.
 *
 * The parser may be called during parameter initialization (initiated by
 * the CALL meta-code instruction), and to parse the executable portion
 * (from the EXEC instruction).
 *
 * CONSTANT's are put on the dictionary by addconst() rather than the operand
 *   stack to avoid conflict with the code being created.  They are accessed
 *   by using the yylval of IDENT and CONSTANT as dictionary indices that
 *   point to struct operands.  This is facilitated with the stkop() macro.
 *   Make sure that topd and topcs are restored on return to discard these
 *   temporaries.
 * When building offsets for branches, such as BIFF and GOTO, allow
 *   for the advancement of the pc by the size of the instruction (in ints).
 *   See opcodes.c for the code executed by the branch instructions.
 */

extern	int cldebug;
#define	lint			/* turns off sccsid in Yacc parser	*/

/* shorthand way to get at operands in dictionary. x will be values returned
 * from addconst() by way of $n's from CONSTANT and IDENT tokens; see gram.c
 * and its uses in grammar.l. also see pushop() for a description of the stack.
 */
#define	stkop(x)	(reference (operand, (x)))

int	dobkg 		= 0;	/* set when want to do code in bkground	*/
int	npipes 		= 0;	/* number of pipes in a command		*/
int	pipe_pc		= 0;	/* pc of last ADDPIPE instruction	*/
int	posit 		= 0;	/* positional argument count		*/
int	inarglist 	= 0;	/* set when in argument list		*/
int	parenlevel 	= 0;	/* level of paren nesting in command	*/
int 	in_iferr 	= 0;	/* in an iferr block			*/
int	cl_level	= 0;	/* CL calling level			*/

int	index_cnt;		/* Index counter in array ref's		*/
char	curr_param[SZ_FNAME];	/* Parameter name of ref's		*/
char	curr_task[SZ_FNAME];	/* ltaskname of command 		*/
int	stmt_pc;		/* PC at beginning of current statement */
int	varlist;		/* Declaration is list directed.	*/
int	vartype;		/* Type of declaration.			*/
int	do_params;		/* Are param definitions legal here?	*/
int	errcnt;			/* Syntax error count.			*/
int	inited;			/* Was variable already initialized.	*/
struct	param *pp;		/* Pointer to param being compiled.	*/
int	n_aval;			/* Number of array init values.		*/
int	lastref;		/* Was last ref an array?		*/
int	for_expr;		/* Was there an expression in FOR?	*/
char	*ifseen;		/* Have we just processed an IF?	*/
char	*errmsg;		/* Syntax error message.		*/

/* context-sensitive switches. technique is ok, but beware of nesting!
 */
static	int absmode 	= 0;	/* set by first absolute mode arg in cmd*/
static	int newstdout 	= 0;	/* set if stdout redirected in arg	*/
static	int bracelevel 	= 0;	/* set while in s_list to inhibit &	*/
static	int tbrace 	= 0;	/* fake braces for declarations		*/
static	int dobrace 	= 0;	/* handling braces.			*/
static	int sawnl 	= 0;	/* set when EOST was \n, else 0		*/
static	int printstmt 	= 0;	/* set when parsing FPRINT statement	*/
static	int scanstmt 	= 0;	/* set when parsing SCAN statement	*/
static	int iferr_tok 	= 0;	/* iferr/ifnoerr token type seen	*/

/* printf-format error messages.
 */
char *arrdeferr   = "Error in array initialization for `%s'.";
char *badparm     = "Parameter definition of `%s' is illegal here.";
char *inval_arr   = "Invalid array type for `%s'.";
char *inv_index   = "Invalid index definition for `%s'.";
char *twoinits    = "Two initializations for parameter `%s'.";

char *exlimits    = "Explicit range required for loop in external param.";
char *illegalvar  = "Illegal variable declarations.";
char *locallist   = "Local list variables are not permitted.";
char *nestediferr = "Nested iferr not allowed in test or handler block.";
char *posfirst    = "All positional arguments must be first";


extern	char	cmdblk[SZ_CMDBLK+1];	/* Command buffer in history.c */
extern	char	*ip_cmdblk;		/* Pointer to current char in command.*/
extern	char	*err_cmdblk;		/* ip_cmdblk when error detected. */

char	*index();
struct	param *initparam();
struct	label *getlabel(), *setlabel();

/* arbitrary large number for bracelevel in a procedure script 
 */
#define MAX_ERR    10
#define EYYERROR  { err_cmdblk = ip_cmdblk; YYERROR; }

#line 130 "y.tab.c"
#define YYERRCODE 256
#define Y_SCAN 257
#define Y_SCANF 258
#define Y_FSCAN 259
#define Y_FSCANF 260
#define Y_OSESC 261
#define Y_APPEND 262
#define Y_ALLAPPEND 263
#define Y_ALLREDIR 264
#define Y_GSREDIR 265
#define Y_ALLPIPE 266
#define D_D 267
#define D_PEEK 268
#define Y_NEWLINE 269
#define Y_CONSTANT 270
#define Y_IDENT 271
#define Y_WHILE 272
#define Y_IF 273
#define Y_ELSE 274
#define Y_FOR 275
#define Y_BREAK 276
#define Y_NEXT 277
#define Y_SWITCH 278
#define Y_CASE 279
#define Y_DEFAULT 280
#define Y_RETURN 281
#define Y_GOTO 282
#define Y_PROCEDURE 283
#define Y_BEGIN 284
#define Y_END 285
#define Y_BOOL 286
#define Y_INT 287
#define Y_REAL 288
#define Y_STRING 289
#define Y_FILE 290
#define Y_STRUCT 291
#define Y_GCUR 292
#define Y_IMCUR 293
#define Y_UKEY 294
#define Y_PSET 295
#define Y_IFERR 296
#define Y_IFNOERR 297
#define Y_THEN 298
#define YOP_AOADD 299
#define YOP_AOSUB 300
#define YOP_AOMUL 301
#define YOP_AODIV 302
#define YOP_AOCAT 303
#define YOP_OR 304
#define YOP_AND 305
#define YOP_EQ 306
#define YOP_NE 307
#define YOP_LE 308
#define YOP_GE 309
#define YOP_CONCAT 310
#define YOP_NOT 311
#define UMINUS 312
#define YOP_POW 313
const short yylhs[] = {                                        -1,
    0,    0,    3,    0,    0,    0,    0,    2,    9,    2,
    7,    7,    7,    5,   14,    6,   18,   10,   19,   19,
   21,   21,   23,   23,   11,   11,   25,   25,   26,   26,
   26,   30,   27,   28,   28,   28,   28,   28,   28,   28,
   28,   28,   28,   29,   29,   31,   31,   32,   36,   32,
   34,   38,   34,   37,   37,   39,   39,   39,   40,   40,
   35,   35,   42,   42,   41,   41,   43,   44,   44,   33,
   33,   33,   45,   45,   46,   12,   47,   47,   48,   48,
   48,   48,   48,   48,   50,   50,   50,   50,   50,   50,
   50,   50,   50,   50,   50,   50,   50,   50,   50,   50,
   50,   50,   52,   50,   54,   50,   55,   50,   56,   50,
   59,   50,   57,   57,   57,   53,   51,   51,   51,   58,
   58,   58,   61,   61,   61,   61,   61,   61,   61,   61,
   61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
   61,   61,   61,   61,   62,   62,   85,   86,   84,   13,
   13,   63,   63,   89,   63,   87,   88,   88,   88,   88,
   88,   92,   64,   91,   94,   91,   93,   93,   97,   99,
   90,  102,   98,   98,  101,  101,  103,  103,  103,  103,
  103,  103,  103,  103,  103,  103,  103,  103,  103,  104,
  104,   65,   65,   66,   67,   68,   71,  107,  109,  105,
  110,   72,  106,  106,  108,  108,   69,  112,  111,  113,
   70,  114,  115,   73,  118,  119,  120,   74,  116,  116,
  117,  117,  121,   75,  123,  124,   76,  125,   77,   78,
   79,   81,   81,   16,  126,   82,   80,   83,   83,  127,
    4,    4,    4,  122,  122,  128,   15,   15,   49,  129,
   49,  130,  132,  130,  131,  131,  131,  131,   60,   17,
   95,    8,    8,   24,   96,   96,  100,  100,   20,   22,
    1,
};
const short yylen[] = {                                         2,
    0,    2,    0,    4,    1,    1,    2,    0,    0,    4,
    1,    2,    1,    3,    0,    5,    0,    5,    0,    3,
    0,    1,    1,    3,    0,    1,    1,    2,    1,    1,
    2,    0,    4,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    3,    1,    5,    1,    0,    4,
    1,    0,    5,    1,    2,    0,    1,    3,    1,    3,
    1,    3,    1,    4,    1,    1,    2,    1,    1,    3,
    1,    1,    1,    3,    3,    2,    1,    1,    1,    1,
    1,    1,    1,    1,    3,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    2,    2,    0,    5,    0,    7,    0,    5,    0,    9,
    0,    5,    1,    1,    1,    1,    0,    1,    3,    0,
    1,    3,    1,    2,    2,    2,    2,    2,    2,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    2,    2,
    2,    2,    1,    1,    1,    2,    0,    0,    6,    0,
    3,    3,    3,    0,    4,    1,    1,    1,    1,    1,
    1,    0,    3,    0,    0,    4,    2,    2,    0,    0,
    6,    0,    3,    1,    1,    3,    0,    1,    1,    3,
    3,    2,    2,    2,    2,    2,    2,    2,    2,    1,
    1,    2,    2,    2,    1,    1,    1,    0,    0,    7,
    0,    5,    1,    1,    0,    1,    1,    0,    7,    0,
    5,    0,    0,    8,    0,    0,    0,   16,    1,    0,
    1,    0,    0,   10,    0,    0,    7,    0,    5,    1,
    1,    1,    2,    2,    0,    5,    2,    1,    2,    0,
    2,    1,    2,    1,    3,    1,    0,    1,    1,    0,
    5,    1,    0,    4,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    0,    1,    0,    1,    1,    1,
    1,
};
const short yydefred[] = {                                      0,
    0,   17,    0,    0,    3,    5,    6,    0,   15,  271,
    7,    0,   76,    2,    0,    0,   34,   42,   36,   35,
   37,   43,   38,   39,   40,   41,  263,  262,   29,    0,
    0,   27,   30,   32,  150,  260,    0,   11,    0,   13,
    0,    0,   31,   14,   28,    0,    0,  269,    0,    0,
   12,    0,    4,  242,    0,    9,    0,   54,    0,    0,
    0,    0,    0,  248,    0,   18,   23,    0,    0,  243,
  195,    0,    0,    0,    0,  231,  230,    0,  225,    0,
    0,    0,  203,  204,  156,  147,    0,    0,    0,  241,
  123,    0,    0,    0,    0,    0,    0,  130,  131,  132,
  133,  134,  135,  136,  137,  138,    0,    0,    0,    0,
  143,  144,    0,    0,  162,  169,    0,  198,    0,    0,
   55,   33,  264,    0,    0,   49,    0,    0,  151,   16,
  270,   20,    0,    0,  212,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   80,    0,  114,  115,   81,   82,
   83,   84,    0,    0,    0,    0,   77,   78,   79,    0,
  113,  237,  150,  239,    0,    0,    0,  124,  125,  126,
  127,  128,  129,  139,  140,  141,  142,  146,    0,    0,
    0,  164,    0,  201,    0,  210,   10,   45,    0,    0,
   68,   69,    0,    0,   63,   61,   66,    0,    0,   73,
    0,    0,  234,   24,  235,    0,    0,    0,    0,   65,
  246,    0,    0,  228,  103,  105,  107,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  111,    0,    0,    0,
    0,  157,  158,  159,  160,  161,    0,    0,  266,  170,
    0,  199,    0,    0,    0,    0,    0,   67,    0,    0,
    0,   57,    0,    0,    0,  208,    0,  219,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   85,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  257,    0,    0,    0,
    0,    0,    0,    0,  165,    0,    0,    0,    0,    0,
   75,   47,   62,    0,   74,    0,   53,    0,    0,  236,
  213,    0,    0,    0,    0,  226,  245,  229,    0,    0,
    0,    0,    0,  109,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   90,    0,
    0,    0,  251,    0,  168,  167,    0,    0,    0,    0,
    0,    0,    0,    0,  172,    0,    0,    0,    0,  175,
  202,  206,    0,  211,   64,   58,   60,    0,    0,  215,
    0,    0,    0,  104,    0,  108,    0,  112,    0,  149,
    0,  261,  166,    0,    0,  187,  188,  186,  189,  184,
  185,  182,  183,    0,    0,  268,  171,    0,    0,    0,
  209,    0,    0,  227,  119,    0,    0,    0,  254,    0,
    0,    0,  176,  200,  214,    0,    0,  223,  106,    0,
    0,    0,    0,  216,  224,  110,    0,    0,    0,  217,
    0,  218,
};
const short yydgoto[] = {                                       5,
   64,   41,   15,  129,    6,    7,   42,   29,  120,    8,
   30,    9,   47,   35,   65,  130,   88,   12,   49,  155,
   68,  132,   69,  259,   31,   32,   54,   34,   59,   46,
   60,   61,  193,   62,  194,  201,   63,  127,  261,  262,
  195,  196,  197,  198,  199,  200,  179,  157,  158,  159,
  330,  274,  332,  275,  276,  387,  160,  351,  294,  161,
   90,   91,   92,   93,   94,   95,   96,   97,   98,   99,
  100,  101,  102,  103,  104,  105,  106,  107,  108,  109,
  110,  111,  112,  113,  163,  352,  114,  247,  167,  115,
  248,  182,  305,  357,  116,  250,  183,  368,  306,  407,
  369,  404,  370,  396,  117,  118,  185,  373,  308,  251,
  119,  322,  253,  206,  378,  269,  427,  412,  437,  441,
  432,  212,  139,  382,  273,  264,   55,  213,  165,  300,
  301,  354,
};
const short yysindex[] = {                                    -41,
 -255,    0, -255, -255,    0,    0,    0,  666,    0,    0,
    0, -210,    0,    0,  -83, -255,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -220,
  666,    0,    0,    0,    0,    0,   32,    0, -190,    0,
 1267,  -10,    0,    0,    0,  -30, -255,    0,  -10, -210,
    0, -255,    0,    0, 1775,    0, -210,    0,  -10,   38,
  -40,   36,    0,    0,  864,    0,    0,   62,   38,    0,
    0,   46,   32,   32,   32,    0,    0, -255,    0,   53,
 1593, -158,    0,    0,    0,    0, -255,    0,   56,    0,
    0,  -10,  -10,  -10,  -10,  -10,  -10,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  -10,  -10,  -10,  -10,
    0,    0, -255, 1593,    0,    0, -156,    0, -152,  -83,
    0,    0,    0,  -30,   20,    0,   29, -255,    0,    0,
    0,    0, -210, -255,    0, 1593, -255,   32,    5, -255,
   32,   32,   32,   32,    0,    0,    0,    0,    0,    0,
    0,    0, 1593, 1593, 1593, 1086,    0,    0,    0,   32,
    0,    0,    0,    0,   33, 1593, -209,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0, 1086,    0,
    0,    0,   32,    0,    2,    0,    0,    0,   32,   65,
    0,    0,   69,   38,    0,    0,    0, -141,   38,    0,
   15,    5,    0,    0,    0, 1593, 1074, -210, -255,    0,
    0,   73,   38,    0,    0,    0,    0, -139, -180, -180,
 1074, -255, -255, -255, -255, -255, -255, -255, -255, -255,
 -255, -255, -255, -255, -255, -255,    0, -255, 1545,    0,
    0,    0,    0,    0,    0,    0, 1593,  -50,    0,    0,
 -255,    0, -255,    5,    5,   11,   20,    0, -132,   38,
   -4,    0,   82, 1267, 1074,    0,   56,    0,   84, 1593,
 -255,    5, 1267, -130, 1593, -130,   38,    0, 1593, 1593,
 1593, 1593, 1593, 1593, 1593, 1593, 1593, 1593, 1593, 1593,
 1593, 1593, 1593, 1593, 1267,    0,    0,    0,    0,   58,
    0, 1086, -255, -255,    0, 1213, 1267, -144, 1267,   62,
    0,    0,    0,   38,    0,   15,    0,    5,    5,    0,
    0, -255, 1593, -255, 1025,    0,    0,    0,   38,   62,
 1086,   38,   62,    0,  578,  511,  -27,  -27,  -36,  -36,
  -36,  -36,  -20,  -16,  -16, -180, -180, -180,    0, 1086,
   27,   30,    0,   38,    0,    0, -113, 1593, 1593, 1593,
 1593, 1593, 1593,   64,    0,    0,   99,   62,   38,    0,
    0,    0, -255,    0,    0,    0,    0, -255, 1267,    0,
   62, 1267, -130,    0, -130,    0, 1593,    0, 1593,    0,
 1545,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, 1536, 1593,    0,    0, 1536, 1267, 1267,
    0, 1593, -255,    0,    0,   62,   38, 1086,    0,   38,
    0,    0,    0,    0,    0, 1086,  102,    0,    0, -130,
 -255, 1267,   62,    0,    0,    0, -210,   62, -255,    0,
 1775,    0,
};
const short yyrindex[] = {                                    482,
    0,    0,    0,    0,    0,    0,    0, -122,    0,    0,
    0,    0,    0,    0, 2157,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 -103,    0,    0,    0,    0,    0,   -7,    0,    0,    0,
 2245,    0,    0,    0,    0,    0, 2006,    0,    0,  142,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   37,
   40,  100,  169,    0, 2245,    0,    0,    0,  145,    0,
    0, 1481,    0,    0,    0,    0,    0,  150,    0,    0,
   41,    0,    0,    0,    0,    0,  130,  674, -154,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  219,   47,    0,    0,  307,    0,  394, 2157,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, 2199,    0,    0,  -35,    0,    0, 2199,
    0,    0,    0,    0,    0,  743,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   49,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   51,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  904,
  977,    0, 1852,    0,    0,    0,    0,    0,  144,    0,
    0,    0,    0,  134,    0,    0,    0,    0,  140,    0,
    0,    9,    0,    0,    0,    0,    0,  141, 1632,    0,
    0,    0,  152,    0,    0,    0,    0,    0, 1261, 1308,
    0, 1632, 1632, 1632, 1632, 1632, 1632, 1632, 1632, 1632,
 1632, 1632, 1632, 1632, 1632, 1632,    0, 2065,    0,  399,
  487,    0,    0,    0,    0,    0,    0,   68,    0,    0,
 2199,    0, 2199,    0,    0,    0,    0,    0,    0,  -18,
    0,    0,   22, 2245,    0,    0, -154,    0,    0,    0,
 2199,    0, 2245,  161,    0,  161,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   35, 1823,  164,    0, 1052, 1156,    0,
   23,   10,  -57,  -57,    0,   18, 2245, 2109, 2245,    0,
    0,    0,    0,  170,    0,    0,    0,    0,    0,    0,
    0, 2199,    0, 1584,  179,    0,    0,    0,  190,    0,
  188,    0,    0,    0,  964,  966, 1143, 1776, 1601, 1920,
 1945, 1967, 1900, 1872, 1892, 1361, 1393, 1451,    0,   44,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   -5,    0,  769,  800,  -29,   94,    0,
    0,    0, 2199,    0,    0,    0,    0, 2199, 2245,    0,
    0, 2245,  161,    0,  161,    0,    0,    0,    0,    0,
    0,    0,    0,  569,  861,    0,    0,    0,    0,    0,
    0,    0,    0,   93,    0,    0,    0,   93, 2245, 2245,
    0,  174, 2199,    0,    0,    0,    0,   57,    0,  586,
  872,  956,    0,    0,    0,  176,    0,    0,    0,  161,
  -33, 2245,    0,    0,    0,    0,  198,    0, 2289,    0,
    0,    0,
};
const short yygindex[] = {                                      0,
 2497,  126,    0,  -39,    0,    0,    0, 1440,    0,    0,
    0,  217,   86,    0,  -59,    0,  -12,    0,    0, 1546,
    0, 1381,    0,  -56,    0,  221,   39,    0,  148,    0,
    0,    0,    0,    0,   87,    0,    0,    0,    0,  -49,
 1024, -229,    0,    0,   54,   79,   42,  336,  -52, -193,
 -203,    0,  -91,    0,    0,    0,    0,    0,    0,    0,
 -126,    0, -179,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  156,    0,    0,  -45,    0,    0,   -2,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  -47,    0,  -43,   14,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  -79,    0,    0,    0,    0,
    0,   95,    0,    0,    0,    0,    0,    0,    0,  -13,
    0,    0,
};
#define YYTABLESIZE 2625
const short yytable[] = {                                      37,
  235,   53,   89,  124,    4,  233,  231,  247,  232,  235,
  234,   57,  133,   10,  233,  231,  235,  232,  138,  234,
  235,  233,  231,  247,  232,  233,  234,  313,  268,  267,
  234,  249,  226,   58,  227,  249,  249,   67,  249,  123,
   50,  249,   40,  166,  121,  299,   33,  191,   27,  192,
  155,   19,   56,  249,  249,  249,  249,  191,  177,  192,
   36,  181,  191,    3,  192,   59,  253,  131,  155,   33,
  123,   48,  333,  304,  205,  120,  177,  208,  120,   51,
  214,  123,  125,   46,  121,  250,  313,  121,  317,  242,
  243,  244,  245,  246,  267,   44,  126,  122,   46,  232,
  122,   56,  131,  134,   50,  196,  402,  233,  403,  194,
  140,   58,  162,  241,   59,  252,   85,  184,  249,  202,
  204,  186,  156,  239,   86,  255,  163,  256,  258,  238,
  271,  277,  236,  177,  174,  312,  177,  257,  190,  319,
  329,  177,  324,   48,  154,  154,  154,  154,  154,  270,
  353,  177,  174,  372,  390,  267,  272,  392,   48,  405,
  431,   25,  279,  280,  281,  282,  283,  284,  285,  286,
  287,  288,  289,  290,  291,  292,  293,  207,  295,  415,
   26,  416,   21,   38,   39,   22,  298,   65,  238,  247,
  238,  307,   71,  309,  219,  220,  221,  299,   72,  220,
   80,  117,   65,  316,  318,   80,   80,  258,   80,  244,
   80,  326,   51,  247,    1,  303,  177,  174,  145,  247,
  334,  323,   48,   80,  320,   80,  433,   51,   70,   51,
  118,  116,  222,  328,  221,  247,  267,  247,  220,  267,
   36,    2,    3,  355,  356,  187,   44,  265,  238,  365,
   50,   45,  238,  367,  238,  238,  258,  268,   10,   52,
  249,   19,  379,  249,  380,  381,   65,  371,  376,  374,
  241,  188,  383,  230,  210,  385,  236,  145,  155,  145,
  228,  229,  230,  177,  189,  236,  177,  260,  302,  189,
  190,   51,  236,  364,  389,  417,  236,  391,  249,  249,
  249,  249,  249,  249,  249,   44,  197,  249,   46,  232,
  314,  325,  408,  409,  442,  196,  331,  233,  410,  194,
  335,  336,  337,  338,  339,  340,  341,  342,  343,  344,
  345,  346,  347,  348,  349,  350,  163,  315,  298,  411,
  252,  145,  414,  145,  145,  394,  394,  394,  394,  394,
  394,  367,  422,  428,  393,  367,  420,  438,  177,  174,
  430,  177,  174,  408,  423,  197,  327,  197,   48,  424,
  425,  434,  397,  398,  399,  400,  401,  419,    0,  440,
    0,    0,    0,    0,  267,  238,    0,    0,   89,    0,
  238,  364,  435,  207,    0,  364,  238,  238,    0,    0,
  238,  238,  238,  238,  238,  238,  238,  238,  238,  238,
  238,  238,   65,    0,  238,  238,  238,  238,  238,  238,
  238,  238,  238,  238,  238,  238,  238,    0,  331,  197,
  418,  197,  197,    0,    0,   77,    0,   51,    0,  152,
   77,   77,    0,   77,    0,   77,    0,    0,    0,  180,
    0,    0,  207,  426,  207,    0,    0,  152,   77,    0,
   77,    0,    0,    0,    0,    0,    0,   80,   80,   80,
   80,   80,   80,   80,  145,    0,   80,    0,    0,  145,
    0,    1,    0,    0,    0,  145,  145,    0,    0,  145,
  145,  145,  145,  145,  145,  145,  145,  145,  145,  145,
  145,  240,    0,  145,  145,  145,  145,  145,  145,  145,
  145,  145,  145,  145,  145,  145,  207,    0,  207,  207,
    0,    0,    0,   78,    0,    0,    0,  153,   78,   78,
    0,   78,    0,   78,    0,    0,    0,    0,    0,    0,
    1,    0,    1,    0,    0,  153,   78,  235,   78,    0,
    0,    0,  233,  231,    0,  232,    0,  234,    0,    0,
    0,    0,  197,    0,    0,    0,    0,  197,    0,    0,
  226,    0,  227,  197,  197,  197,    0,  197,  197,  197,
    0,  197,  197,  197,  197,  197,  197,  197,  197,    0,
    0,  197,  197,  197,  197,  197,  197,  197,  197,  197,
  197,  197,  197,  197,    1,  249,    0,    1,    0,  191,
  249,  249,  191,  249,  235,  249,    0,    0,    0,  233,
  231,    0,  232,    0,  234,    0,  173,  191,  249,    0,
  249,    0,    0,    0,    0,    0,    0,  226,    0,  227,
    0,  366,    0,    0,  173,    0,    0,    0,    0,  207,
    0,    0,    0,    0,  207,    0,    0,    0,  240,  250,
  207,  207,  207,    0,  207,  207,  207,  152,  207,  207,
  207,  207,  207,  207,  207,  207,    0,    0,  207,  207,
  207,  207,  207,  207,  207,  207,  207,  207,  207,  207,
  207,    0,  191,  395,  395,  395,  395,  395,  395,    0,
    0,    0,   77,   77,   77,   77,   77,   77,   77,  173,
  249,   77,    0,    0,  249,  249,  249,  249,  249,    0,
  249,    0,    0,    0,   27,    0,    0,    0,    0,    0,
    0,    0,  249,  249,  249,  249,    0,    0,    0,  366,
  421,    0,    1,  366,    0,    0,    0,    0,    1,    1,
    0,    0,    1,    1,    1,  153,    1,    1,    1,    1,
    1,    1,    1,    1,  250,    0,  249,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,  260,
    0,    0,  259,  260,  260,  260,  260,  260,    0,  260,
   78,   78,   78,   78,   78,   78,   78,  249,    0,   78,
    0,  260,  260,  260,  260,   77,    0,    0,    0,  178,
   77,   77,  178,   77,    0,   77,  224,  225,  228,  229,
  230,    0,    0,  236,    0,    0,    0,  178,   77,    0,
   77,    0,    0,  260,  191,  260,   78,  191,    0,    0,
  179,   78,   78,  179,   78,    0,   78,    0,    0,    0,
    0,  173,    0,    0,  173,    0,    0,    0,  179,   78,
    0,   78,    0,    0,    0,    0,  260,    0,    0,    0,
    0,    0,  249,  249,  249,  249,  249,  249,  249,    0,
    0,  249,  223,  224,  225,  228,  229,  230,    0,    0,
  236,    0,  178,    0,    0,    0,    0,   77,    0,    0,
    0,  190,   77,   77,  190,   77,    0,   77,   77,    0,
    0,    0,  180,   77,   77,  180,   77,    0,   77,  190,
   77,   16,   77,  179,    0,    0,    0,    0,    0,    0,
  180,   77,    0,   77,   10,    0,    0,    0,    0,  249,
   77,    0,  249,    0,    0,   77,   77,    0,   77,    0,
   77,   17,   18,   19,   20,   21,   22,   23,   24,   25,
   26,    0,  192,   77,    0,   77,    0,    0,    0,    0,
    0,    0,  249,  249,  249,  249,  249,  249,  249,  249,
  249,  249,  249,  249,  190,    0,  249,    0,    0,    0,
    0,    0,   78,    0,    0,  180,  181,   78,   78,  181,
   78,    0,   78,    0,   99,    0,  100,   99,  260,  100,
    0,  260,    0,   78,  181,   78,    0,   78,   78,   78,
    0,   78,   99,   78,  100,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  178,  193,   78,  178,   78,    0,
    0,    0,    0,    0,    0,    0,  260,  260,  260,  260,
  260,  260,  260,    0,    0,  260,   99,    0,  100,    0,
    0,  235,    0,    0,    0,  179,  233,  231,  179,  232,
    0,  234,   77,   77,   77,   77,   77,   77,   77,  181,
    0,   77,    0,    0,  226,    0,  227,   99,   78,  100,
    0,    0,    0,   78,   78,  256,   78,    0,   78,    0,
    0,    0,    0,   78,   78,   78,   78,   78,   78,   78,
  235,   78,   78,   78,  131,  233,  231,    0,  232,   52,
  234,    0,  235,    0,    0,    0,  190,  233,  231,  190,
  232,    0,  234,  226,    0,  227,    0,  180,    0,    0,
  180,    0,    0,    0,  256,  226,    0,  227,  128,   17,
   18,   19,   20,   21,   22,   23,   24,   25,   26,    0,
    0,    0,  211,    0,   77,   77,   77,   77,   77,   77,
   77,    0,  192,   77,    0,   77,   77,   77,   77,   77,
   77,   77,    0,   97,   77,    0,   97,    0,    0,    0,
    0,    0,   79,    0,    0,    0,    0,   79,   79,  255,
   79,   97,   79,    0,    0,    0,    0,   77,   77,   77,
   77,   77,   77,   77,    0,   79,   77,   79,    0,    0,
    0,  181,    0,    0,  181,  263,    0,    0,    0,   99,
    0,  100,   99,    0,  100,   97,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  193,    0,    0,  255,    0,
    0,    0,   48,    0,    0,    0,  123,  153,    0,   78,
   78,   78,   78,   78,   78,   78,   97,   99,   78,  100,
  100,    0,  362,    0,  363,    0,    0,  310,  311,    0,
   78,   78,   78,   78,   78,   78,   78,    0,    0,   78,
    0,    0,    0,   10,    0,  211,    0,  102,    0,    0,
    0,  102,  102,  102,  102,  102,    0,  102,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  102,
  102,    0,  102,    0,    0,    0,    0,    0,  222,  223,
  224,  225,  228,  229,  230,    0,    0,  236,    0,    0,
    0,  263,  377,    0,  101,    0,    0,    0,  101,  101,
  101,  101,  101,  102,  101,   78,   78,   78,   78,   78,
   78,   78,    0,    0,   78,    0,  101,  101,    0,  101,
    0,    0,    0,    0,    0,    0,    0,  222,  223,  224,
  225,  228,  229,  230,  102,    0,  236,    0,    0,  222,
  223,  224,  225,  228,  229,  230,    0,   88,  236,    0,
  101,   88,   88,   88,   88,   88,    0,   88,   97,    0,
    0,   97,    0,    0,    0,    0,    0,    0,    0,   88,
   88,    0,   88,    0,    0,    0,    0,    0,    0,   89,
    0,  101,    0,   89,   89,   89,   89,   89,    0,   89,
    0,    0,    0,    0,    0,    0,   97,   97,   97,   97,
    0,   89,   89,   88,   89,    0,    0,    0,    0,   79,
   79,   79,   79,   79,   79,   79,    0,    0,   79,  141,
  142,  143,  144,    0,  358,  359,  360,  361,    0,    0,
    0,   56,  145,  146,   88,   89,    0,   91,   66,    0,
    0,   91,   91,   91,   91,   91,    0,   91,  122,  147,
  148,    0,    0,    0,  149,  150,  151,  152,    0,   91,
   91,    0,   91,    0,    0,    0,   89,    0,    0,    0,
  261,  261,   52,  154,  261,  261,  102,    0,    0,  102,
    0,  168,  169,  170,  171,  172,  173,    0,    0,  261,
  261,  260,  261,   91,    0,    0,  174,  175,  176,  177,
    0,    0,   17,   18,   19,   20,   21,   22,   23,   24,
   25,   26,    0,    0,  102,  102,  102,  102,  102,  102,
  102,  260,    0,  101,   91,   48,  101,    0,    0,    0,
  153,    0,   50,    0,   48,    0,  297,  266,    0,  153,
    0,    0,    0,    0,    0,  362,    0,  363,    0,    0,
    0,  278,    0,    0,  261,    0,    0,    0,    0,    0,
    0,  101,  101,  101,  101,  101,  101,  101,  135,  136,
  137,    0,    0,  247,    0,    0,   88,    0,  247,   88,
    0,    0,   48,    0,    0,    0,    0,  153,    0,    0,
    0,   93,  247,    0,   93,  321,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   89,   93,
   93,   89,   93,    0,   88,   88,   88,   88,   88,   88,
   88,  247,    0,    0,    0,    0,  247,    0,    0,    0,
    0,    0,    0,  209,    0,    0,  215,  216,  217,  218,
  375,    0,    0,   93,    0,    0,   89,   89,   89,   89,
   89,   89,   89,    0,    0,  237,    0,    0,    0,    0,
  384,    0,    0,  386,    0,    0,   91,    0,    0,   91,
    0,    0,    0,    0,   93,    0,    0,    0,  249,    0,
    0,  388,    0,    0,  254,    0,    0,  261,  261,  261,
  261,    0,  261,  261,  261,  261,  261,    0,  406,  261,
  261,  261,    0,    0,   91,   91,   91,   91,   91,   91,
   91,  413,    0,    0,    0,    0,    0,  261,  261,    0,
    0,    0,  261,  261,  261,  261,    0,    0,    0,  260,
  260,  260,  260,  260,    0,    0,    0,    0,    0,    0,
    0,  261,  141,  142,  143,  144,  429,  358,  359,  360,
  361,  141,  142,  143,  144,  145,  146,    0,    0,    0,
    0,    0,    0,  436,  296,  146,   98,    0,  439,   98,
    0,    0,  147,  148,    0,    0,    0,  149,  150,  151,
  152,  147,  148,   87,   98,   85,  149,  150,  151,  152,
  247,  247,  247,  247,    0,    0,  154,    0,    0,  141,
  142,  143,  144,  247,  247,  154,    0,    0,    0,    0,
    0,    0,  145,  146,    0,    0,   93,    0,   98,   93,
  247,  247,    0,    0,    0,  247,  247,  247,  247,  147,
  148,  240,    0,  240,  149,  150,  151,  152,  247,  247,
  247,  247,  265,    0,  247,  265,  265,   86,    0,   98,
    0,  247,  247,  154,   93,   93,   93,   93,   93,   93,
  265,  265,   86,  265,   86,   86,   86,    0,  247,  247,
    0,    0,    0,  247,  247,  247,  247,    0,    0,    0,
   86,   86,   87,   86,   87,   87,   87,    0,    0,    0,
   92,    0,  247,   92,    0,  240,    0,  148,    0,    0,
   87,   87,    0,   87,    0,    0,    0,    0,   92,   92,
   94,   92,    0,   94,   86,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  265,    0,    0,   94,   94,
    0,   94,    0,    0,   87,   95,    0,    0,   95,    0,
    0,    0,   92,    0,    0,   86,    0,    0,    0,    0,
    0,    0,    0,   95,   95,    0,   95,   96,    0,    0,
   96,    0,   94,    0,    0,   87,    0,    0,    0,    0,
    0,    0,    0,   92,    0,   96,   96,    0,   96,    0,
    0,    0,    0,    0,    0,   71,    0,   95,    0,    0,
    0,   98,    0,   94,   98,   72,   73,   74,    0,   75,
   76,   77,   78,   79,   80,   81,   82,    0,    0,   96,
    0,    0,    0,    0,  247,    0,  247,    0,   95,    0,
   83,   84,    0,    0,    0,    0,    0,    0,    0,   98,
   98,   98,   98,  240,    0,    0,    0,    0,    0,    0,
   96,    0,    0,  240,  240,  240,    0,  240,  240,  240,
  240,  240,  240,  240,  240,    0,    0,    0,  265,  265,
  265,  265,    0,  265,  265,  265,  265,  265,  240,  240,
  265,  265,  265,  247,    0,  247,    0,    0,  247,    0,
    0,    0,    0,    0,    0,    0,    0,   86,  265,  265,
   86,    0,    0,  265,  265,  265,  265,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   87,    0,    0,
   87,    0,  265,    0,    0,   92,    0,  205,   92,  205,
    0,    0,    0,    0,    0,   86,   86,   86,   86,   86,
   86,   86,    0,    0,    0,   94,    0,  247,   94,  247,
    0,    0,    0,    0,    0,   87,   87,   87,   87,   87,
   87,   87,    0,   92,   92,   92,   92,   92,   92,   92,
   95,    0,    0,   95,    0,    8,    0,    8,    0,    0,
    0,    0,    0,   94,   94,   94,   94,   94,   94,    0,
    0,  205,   96,    0,    0,   96,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   95,   95,
   95,   95,   95,   95,    0,    0,    0,  247,    0,  247,
    0,  247,    0,    0,    0,    0,  247,    0,    0,    0,
   96,   96,   96,   96,   96,   96,  247,  247,  247,    8,
  247,  247,  247,  247,  247,  247,  247,  247,    0,    0,
  247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
  247,  247,  247,  240,    0,  240,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  247,  247,    0,    0,    0,  247,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  247,  247,  247,    0,  247,
  247,  247,  247,  247,  247,  247,  247,  247,    0,  247,
  247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
  247,  247,    0,    0,  205,    0,    0,  240,    0,  205,
    0,    0,    0,    0,    0,    0,    0,  205,    0,  205,
  205,  205,    0,  205,  205,  205,  205,  205,  205,  205,
  205,    0,    0,    0,  205,  205,  205,  205,  205,  205,
  205,  205,  205,  205,  205,  205,    0,    0,    0,    0,
    0,  247,    8,    0,    0,    0,    0,    8,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    8,    8,    8,
    0,    8,    8,    8,    8,    8,    8,    8,    8,    0,
    0,    0,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    8,  247,    0,    0,    0,    0,  247,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  247,
  247,  247,    0,  247,  247,  247,  247,  247,  247,  247,
  247,    0,    0,    0,  247,  247,  247,  247,  247,  247,
  247,  247,  247,  247,  247,  247,    0,   11,    0,   13,
   14,    0,    0,    0,   28,  240,    0,    0,    0,    0,
    0,    0,   43,    0,    0,  240,  240,  240,    0,  240,
  240,  240,  240,  240,  240,  240,  240,   28,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   28,    0,
  240,  240,    0,    0,    0,   28,    0,    0,   70,  247,
    0,    0,    0,    0,    0,   28,    0,    0,    0,  247,
  247,  247,    0,  247,  247,  247,  247,  247,  247,  247,
  247,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  164,  247,  247,    0,    0,   28,   28,
   28,   28,   28,   28,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   28,   28,   28,   28,    0,    0,  178,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  203,
};
const short yycheck[] = {                                      12,
   37,   41,   55,   60,   46,   42,   43,   41,   45,   37,
   47,   42,   69,  269,   42,   43,   37,   45,   78,   47,
   37,   42,   43,   59,   45,   42,   47,  257,  208,   59,
   47,   37,   60,   46,   62,   41,   42,   50,   44,   44,
   59,   47,  126,   89,   57,  239,    8,   43,   59,   45,
   41,   59,   44,   59,   60,   61,   62,   43,   41,   45,
  271,  114,   43,  284,   45,   44,   44,   41,   59,   31,
   44,   40,  276,  124,  134,   41,   59,  137,   44,  270,
  140,   44,  123,   44,   41,   91,  316,   44,   93,  299,
  300,  301,  302,  303,  124,   59,   61,   41,   59,   59,
   44,   93,   41,   58,  123,   59,   43,   59,   45,   59,
   58,  124,  271,  166,   93,   93,   61,  274,  124,   91,
  133,  274,   81,   91,  123,   61,   59,   59,  270,    0,
   58,  271,  313,   41,   41,  125,   44,  194,  271,   58,
  271,  124,   59,   44,  299,  300,  301,  302,  303,  209,
   93,   59,   59,  298,  125,  208,  213,  271,   59,   61,
   59,  284,  222,  223,  224,  225,  226,  227,  228,  229,
  230,  231,  232,  233,  234,  235,  236,  136,  238,  383,
  284,  385,   41,  267,  268,   41,  239,   44,   59,   40,
   61,  251,   59,  253,  153,  154,  155,  391,   59,   59,
   37,   41,   59,  260,  261,   42,   43,   44,   45,   58,
   47,  271,   44,  271,  256,  266,  124,  124,    0,   41,
  277,  267,  123,   60,  264,   62,  430,   59,   59,   61,
   41,   44,   59,  273,   59,  271,  266,  271,   41,  269,
  271,  283,  284,  303,  304,  120,   30,  206,  163,  306,
  269,   31,  123,  306,  125,  126,   93,  437,  269,   91,
  266,  269,  322,  269,  324,  325,  123,  307,  318,  309,
  323,  124,  329,  310,  270,  332,  313,   59,  269,   61,
  308,  309,  310,  266,  270,  313,  269,  201,  247,  270,
  271,  123,  313,  306,  351,  387,  313,  354,  304,  305,
  306,  307,  308,  309,  310,  269,    0,  313,  269,  269,
  257,  270,  369,  373,  441,  269,  275,  269,  378,  269,
  279,  280,  281,  282,  283,  284,  285,  286,  287,  288,
  289,  290,  291,  292,  293,  294,  269,  259,  391,  379,
  185,  123,  382,  125,  126,  358,  359,  360,  361,  362,
  363,  404,  405,  413,  357,  408,  404,  437,  266,  266,
  417,  269,  269,  420,  408,   59,  272,   61,  269,  409,
  410,  431,  359,  360,  361,  362,  363,  391,   -1,  439,
   -1,   -1,   -1,   -1,  437,  256,   -1,   -1,  441,   -1,
  261,  404,  432,    0,   -1,  408,  267,  268,   -1,   -1,
  271,  272,  273,  274,  275,  276,  277,  278,  279,  280,
  281,  282,  269,   -1,  285,  286,  287,  288,  289,  290,
  291,  292,  293,  294,  295,  296,  297,   -1,  387,  123,
  389,  125,  126,   -1,   -1,   37,   -1,  269,   -1,   41,
   42,   43,   -1,   45,   -1,   47,   -1,   -1,   -1,  114,
   -1,   -1,   59,  412,   61,   -1,   -1,   59,   60,   -1,
   62,   -1,   -1,   -1,   -1,   -1,   -1,  304,  305,  306,
  307,  308,  309,  310,  256,   -1,  313,   -1,   -1,  261,
   -1,    0,   -1,   -1,   -1,  267,  268,   -1,   -1,  271,
  272,  273,  274,  275,  276,  277,  278,  279,  280,  281,
  282,  166,   -1,  285,  286,  287,  288,  289,  290,  291,
  292,  293,  294,  295,  296,  297,  123,   -1,  125,  126,
   -1,   -1,   -1,   37,   -1,   -1,   -1,   41,   42,   43,
   -1,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,   -1,
   59,   -1,   61,   -1,   -1,   59,   60,   37,   62,   -1,
   -1,   -1,   42,   43,   -1,   45,   -1,   47,   -1,   -1,
   -1,   -1,  256,   -1,   -1,   -1,   -1,  261,   -1,   -1,
   60,   -1,   62,  267,  268,  269,   -1,  271,  272,  273,
   -1,  275,  276,  277,  278,  279,  280,  281,  282,   -1,
   -1,  285,  286,  287,  288,  289,  290,  291,  292,  293,
  294,  295,  296,  297,  123,   37,   -1,  126,   -1,   41,
   42,   43,   44,   45,   37,   47,   -1,   -1,   -1,   42,
   43,   -1,   45,   -1,   47,   -1,   41,   59,   60,   -1,
   62,   -1,   -1,   -1,   -1,   -1,   -1,   60,   -1,   62,
   -1,  306,   -1,   -1,   59,   -1,   -1,   -1,   -1,  256,
   -1,   -1,   -1,   -1,  261,   -1,   -1,   -1,  323,   91,
  267,  268,  269,   -1,  271,  272,  273,  269,  275,  276,
  277,  278,  279,  280,  281,  282,   -1,   -1,  285,  286,
  287,  288,  289,  290,  291,  292,  293,  294,  295,  296,
  297,   -1,  124,  358,  359,  360,  361,  362,  363,   -1,
   -1,   -1,  304,  305,  306,  307,  308,  309,  310,  124,
   37,  313,   -1,   -1,   41,   42,   43,   44,   45,   -1,
   47,   -1,   -1,   -1,   59,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   59,   60,   61,   62,   -1,   -1,   -1,  404,
  405,   -1,  261,  408,   -1,   -1,   -1,   -1,  267,  268,
   -1,   -1,  271,  272,  273,  269,  275,  276,  277,  278,
  279,  280,  281,  282,   91,   -1,   93,  286,  287,  288,
  289,  290,  291,  292,  293,  294,  295,  296,  297,   37,
   -1,   -1,   40,   41,   42,   43,   44,   45,   -1,   47,
  304,  305,  306,  307,  308,  309,  310,  124,   -1,  313,
   -1,   59,   60,   61,   62,   37,   -1,   -1,   -1,   41,
   42,   43,   44,   45,   -1,   47,  306,  307,  308,  309,
  310,   -1,   -1,  313,   -1,   -1,   -1,   59,   60,   -1,
   62,   -1,   -1,   91,  266,   93,   37,  269,   -1,   -1,
   41,   42,   43,   44,   45,   -1,   47,   -1,   -1,   -1,
   -1,  266,   -1,   -1,  269,   -1,   -1,   -1,   59,   60,
   -1,   62,   -1,   -1,   -1,   -1,  124,   -1,   -1,   -1,
   -1,   -1,  304,  305,  306,  307,  308,  309,  310,   -1,
   -1,  313,  305,  306,  307,  308,  309,  310,   -1,   -1,
  313,   -1,  124,   -1,   -1,   -1,   -1,   37,   -1,   -1,
   -1,   41,   42,   43,   44,   45,   -1,   47,   37,   -1,
   -1,   -1,   41,   42,   43,   44,   45,   -1,   47,   59,
   60,  256,   62,  124,   -1,   -1,   -1,   -1,   -1,   -1,
   59,   60,   -1,   62,  269,   -1,   -1,   -1,   -1,  266,
   37,   -1,  269,   -1,   -1,   42,   43,   -1,   45,   -1,
   47,  286,  287,  288,  289,  290,  291,  292,  293,  294,
  295,   -1,   59,   60,   -1,   62,   -1,   -1,   -1,   -1,
   -1,   -1,  299,  300,  301,  302,  303,  304,  305,  306,
  307,  308,  309,  310,  124,   -1,  313,   -1,   -1,   -1,
   -1,   -1,   37,   -1,   -1,  124,   41,   42,   43,   44,
   45,   -1,   47,   -1,   41,   -1,   41,   44,  266,   44,
   -1,  269,   -1,   37,   59,   60,   -1,   62,   42,   43,
   -1,   45,   59,   47,   59,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  266,   59,   60,  269,   62,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  304,  305,  306,  307,
  308,  309,  310,   -1,   -1,  313,   93,   -1,   93,   -1,
   -1,   37,   -1,   -1,   -1,  266,   42,   43,  269,   45,
   -1,   47,  304,  305,  306,  307,  308,  309,  310,  124,
   -1,  313,   -1,   -1,   60,   -1,   62,  124,   37,  124,
   -1,   -1,   -1,   42,   43,   44,   45,   -1,   47,   -1,
   -1,   -1,   -1,  304,  305,  306,  307,  308,  309,  310,
   37,   60,  313,   62,   41,   42,   43,   -1,   45,  256,
   47,   -1,   37,   -1,   -1,   -1,  266,   42,   43,  269,
   45,   -1,   47,   60,   -1,   62,   -1,  266,   -1,   -1,
  269,   -1,   -1,   -1,   93,   60,   -1,   62,  285,  286,
  287,  288,  289,  290,  291,  292,  293,  294,  295,   -1,
   -1,   -1,  139,   -1,  304,  305,  306,  307,  308,  309,
  310,   -1,  269,  313,   -1,  304,  305,  306,  307,  308,
  309,  310,   -1,   41,  313,   -1,   44,   -1,   -1,   -1,
   -1,   -1,   37,   -1,   -1,   -1,   -1,   42,   43,   44,
   45,   59,   47,   -1,   -1,   -1,   -1,  304,  305,  306,
  307,  308,  309,  310,   -1,   60,  313,   62,   -1,   -1,
   -1,  266,   -1,   -1,  269,  202,   -1,   -1,   -1,  266,
   -1,  266,  269,   -1,  269,   93,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  269,   -1,   -1,   93,   -1,
   -1,   -1,   40,   -1,   -1,   -1,   44,   45,   -1,  304,
  305,  306,  307,  308,  309,  310,  124,  304,  313,  304,
  305,   -1,   60,   -1,   62,   -1,   -1,  254,  255,   -1,
  304,  305,  306,  307,  308,  309,  310,   -1,   -1,  313,
   -1,   -1,   -1,  269,   -1,  272,   -1,   37,   -1,   -1,
   -1,   41,   42,   43,   44,   45,   -1,   47,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   59,
   60,   -1,   62,   -1,   -1,   -1,   -1,   -1,  304,  305,
  306,  307,  308,  309,  310,   -1,   -1,  313,   -1,   -1,
   -1,  318,  319,   -1,   37,   -1,   -1,   -1,   41,   42,
   43,   44,   45,   93,   47,  304,  305,  306,  307,  308,
  309,  310,   -1,   -1,  313,   -1,   59,   60,   -1,   62,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  304,  305,  306,
  307,  308,  309,  310,  124,   -1,  313,   -1,   -1,  304,
  305,  306,  307,  308,  309,  310,   -1,   37,  313,   -1,
   93,   41,   42,   43,   44,   45,   -1,   47,  266,   -1,
   -1,  269,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   59,
   60,   -1,   62,   -1,   -1,   -1,   -1,   -1,   -1,   37,
   -1,  124,   -1,   41,   42,   43,   44,   45,   -1,   47,
   -1,   -1,   -1,   -1,   -1,   -1,  304,  305,  306,  307,
   -1,   59,   60,   93,   62,   -1,   -1,   -1,   -1,  304,
  305,  306,  307,  308,  309,  310,   -1,   -1,  313,  257,
  258,  259,  260,   -1,  262,  263,  264,  265,   -1,   -1,
   -1,   42,  270,  271,  124,   93,   -1,   37,   49,   -1,
   -1,   41,   42,   43,   44,   45,   -1,   47,   59,  287,
  288,   -1,   -1,   -1,  292,  293,  294,  295,   -1,   59,
   60,   -1,   62,   -1,   -1,   -1,  124,   -1,   -1,   -1,
   40,   41,  256,  311,   44,   45,  266,   -1,   -1,  269,
   -1,   92,   93,   94,   95,   96,   97,   -1,   -1,   59,
   60,   61,   62,   93,   -1,   -1,  107,  108,  109,  110,
   -1,   -1,  286,  287,  288,  289,  290,  291,  292,  293,
  294,  295,   -1,   -1,  304,  305,  306,  307,  308,  309,
  310,   91,   -1,  266,  124,   40,  269,   -1,   -1,   -1,
   45,   -1,   37,   -1,   40,   -1,   42,  207,   -1,   45,
   -1,   -1,   -1,   -1,   -1,   60,   -1,   62,   -1,   -1,
   -1,  221,   -1,   -1,  124,   -1,   -1,   -1,   -1,   -1,
   -1,  304,  305,  306,  307,  308,  309,  310,   73,   74,
   75,   -1,   -1,   40,   -1,   -1,  266,   -1,   45,  269,
   -1,   -1,   40,   -1,   -1,   -1,   -1,   45,   -1,   -1,
   -1,   41,   59,   -1,   44,  265,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  266,   59,
   60,  269,   62,   -1,  304,  305,  306,  307,  308,  309,
  310,   40,   -1,   -1,   -1,   -1,   45,   -1,   -1,   -1,
   -1,   -1,   -1,  138,   -1,   -1,  141,  142,  143,  144,
  310,   -1,   -1,   93,   -1,   -1,  304,  305,  306,  307,
  308,  309,  310,   -1,   -1,  160,   -1,   -1,   -1,   -1,
  330,   -1,   -1,  333,   -1,   -1,  266,   -1,   -1,  269,
   -1,   -1,   -1,   -1,  124,   -1,   -1,   -1,  183,   -1,
   -1,  351,   -1,   -1,  189,   -1,   -1,  257,  258,  259,
  260,   -1,  262,  263,  264,  265,  266,   -1,  368,  269,
  270,  271,   -1,   -1,  304,  305,  306,  307,  308,  309,
  310,  381,   -1,   -1,   -1,   -1,   -1,  287,  288,   -1,
   -1,   -1,  292,  293,  294,  295,   -1,   -1,   -1,  299,
  300,  301,  302,  303,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  311,  257,  258,  259,  260,  416,  262,  263,  264,
  265,  257,  258,  259,  260,  270,  271,   -1,   -1,   -1,
   -1,   -1,   -1,  433,  270,  271,   41,   -1,  438,   44,
   -1,   -1,  287,  288,   -1,   -1,   -1,  292,  293,  294,
  295,  287,  288,   59,   59,   61,  292,  293,  294,  295,
  257,  258,  259,  260,   -1,   -1,  311,   -1,   -1,  257,
  258,  259,  260,  270,  271,  311,   -1,   -1,   -1,   -1,
   -1,   -1,  270,  271,   -1,   -1,  266,   -1,   93,  269,
  287,  288,   -1,   -1,   -1,  292,  293,  294,  295,  287,
  288,   59,   -1,   61,  292,  293,  294,  295,  257,  258,
  259,  260,   41,   -1,  311,   44,   45,  123,   -1,  124,
   -1,  270,  271,  311,  304,  305,  306,  307,  308,  309,
   59,   60,   41,   62,   43,   44,   45,   -1,  287,  288,
   -1,   -1,   -1,  292,  293,  294,  295,   -1,   -1,   -1,
   59,   60,   41,   62,   43,   44,   45,   -1,   -1,   -1,
   41,   -1,  311,   44,   -1,  123,   -1,  125,   -1,   -1,
   59,   60,   -1,   62,   -1,   -1,   -1,   -1,   59,   60,
   41,   62,   -1,   44,   93,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  124,   -1,   -1,   59,   60,
   -1,   62,   -1,   -1,   93,   41,   -1,   -1,   44,   -1,
   -1,   -1,   93,   -1,   -1,  124,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   59,   60,   -1,   62,   41,   -1,   -1,
   44,   -1,   93,   -1,   -1,  124,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  124,   -1,   59,   60,   -1,   62,   -1,
   -1,   -1,   -1,   -1,   -1,  261,   -1,   93,   -1,   -1,
   -1,  266,   -1,  124,  269,  271,  272,  273,   -1,  275,
  276,  277,  278,  279,  280,  281,  282,   -1,   -1,   93,
   -1,   -1,   -1,   -1,   59,   -1,   61,   -1,  124,   -1,
  296,  297,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  304,
  305,  306,  307,  261,   -1,   -1,   -1,   -1,   -1,   -1,
  124,   -1,   -1,  271,  272,  273,   -1,  275,  276,  277,
  278,  279,  280,  281,  282,   -1,   -1,   -1,  257,  258,
  259,  260,   -1,  262,  263,  264,  265,  266,  296,  297,
  269,  270,  271,   59,   -1,   61,   -1,   -1,  123,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  266,  287,  288,
  269,   -1,   -1,  292,  293,  294,  295,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  266,   -1,   -1,
  269,   -1,  311,   -1,   -1,  266,   -1,   59,  269,   61,
   -1,   -1,   -1,   -1,   -1,  304,  305,  306,  307,  308,
  309,  310,   -1,   -1,   -1,  266,   -1,  123,  269,  125,
   -1,   -1,   -1,   -1,   -1,  304,  305,  306,  307,  308,
  309,  310,   -1,  304,  305,  306,  307,  308,  309,  310,
  266,   -1,   -1,  269,   -1,   59,   -1,   61,   -1,   -1,
   -1,   -1,   -1,  304,  305,  306,  307,  308,  309,   -1,
   -1,  123,  266,   -1,   -1,  269,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  304,  305,
  306,  307,  308,  309,   -1,   -1,   -1,   59,   -1,   61,
   -1,  256,   -1,   -1,   -1,   -1,  261,   -1,   -1,   -1,
  304,  305,  306,  307,  308,  309,  271,  272,  273,  123,
  275,  276,  277,  278,  279,  280,  281,  282,   -1,   -1,
  285,  286,  287,  288,  289,  290,  291,  292,  293,  294,
  295,  296,  297,   59,   -1,   61,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  256,  123,   -1,   -1,   -1,  261,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  271,  272,  273,   -1,  275,
  276,  277,  278,  279,  280,  281,  282,   59,   -1,   61,
  286,  287,  288,  289,  290,  291,  292,  293,  294,  295,
  296,  297,   -1,   -1,  256,   -1,   -1,  123,   -1,  261,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  269,   -1,  271,
  272,  273,   -1,  275,  276,  277,  278,  279,  280,  281,
  282,   -1,   -1,   -1,  286,  287,  288,  289,  290,  291,
  292,  293,  294,  295,  296,  297,   -1,   -1,   -1,   -1,
   -1,  123,  256,   -1,   -1,   -1,   -1,  261,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  271,  272,  273,
   -1,  275,  276,  277,  278,  279,  280,  281,  282,   -1,
   -1,   -1,  286,  287,  288,  289,  290,  291,  292,  293,
  294,  295,  296,  297,  256,   -1,   -1,   -1,   -1,  261,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  271,
  272,  273,   -1,  275,  276,  277,  278,  279,  280,  281,
  282,   -1,   -1,   -1,  286,  287,  288,  289,  290,  291,
  292,  293,  294,  295,  296,  297,   -1,    1,   -1,    3,
    4,   -1,   -1,   -1,    8,  261,   -1,   -1,   -1,   -1,
   -1,   -1,   16,   -1,   -1,  271,  272,  273,   -1,  275,
  276,  277,  278,  279,  280,  281,  282,   31,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   42,   -1,
  296,  297,   -1,   -1,   -1,   49,   -1,   -1,   52,  261,
   -1,   -1,   -1,   -1,   -1,   59,   -1,   -1,   -1,  271,
  272,  273,   -1,  275,  276,  277,  278,  279,  280,  281,
  282,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   87,  296,  297,   -1,   -1,   92,   93,
   94,   95,   96,   97,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  107,  108,  109,  110,   -1,   -1,  113,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  128,
};
#define YYFINAL 5
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 313
#if YYDEBUG
const char * const yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,"'%'",0,0,"'('","')'","'*'","'+'","','","'-'","'.'","'/'",0,0,0,0,0,0,0,0,
0,0,"':'","';'","'<'","'='","'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,"'{'","'|'","'}'","'~'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"Y_SCAN","Y_SCANF","Y_FSCAN",
"Y_FSCANF","Y_OSESC","Y_APPEND","Y_ALLAPPEND","Y_ALLREDIR","Y_GSREDIR",
"Y_ALLPIPE","D_D","D_PEEK","Y_NEWLINE","Y_CONSTANT","Y_IDENT","Y_WHILE","Y_IF",
"Y_ELSE","Y_FOR","Y_BREAK","Y_NEXT","Y_SWITCH","Y_CASE","Y_DEFAULT","Y_RETURN",
"Y_GOTO","Y_PROCEDURE","Y_BEGIN","Y_END","Y_BOOL","Y_INT","Y_REAL","Y_STRING",
"Y_FILE","Y_STRUCT","Y_GCUR","Y_IMCUR","Y_UKEY","Y_PSET","Y_IFERR","Y_IFNOERR",
"Y_THEN","YOP_AOADD","YOP_AOSUB","YOP_AOMUL","YOP_AODIV","YOP_AOCAT","YOP_OR",
"YOP_AND","YOP_EQ","YOP_NE","YOP_LE","YOP_GE","YOP_CONCAT","YOP_NOT","UMINUS",
"YOP_POW",
};
const char * const yyrule[] = {
"$accept : block",
"block :",
"block : '.' NL",
"$$1 :",
"block : block $$1 debug xstmt",
"block : script_params",
"block : script_body",
"block : error NL",
"debug :",
"$$2 :",
"debug : D_XXX EOST $$2 debug",
"D_XXX : D_D",
"D_XXX : D_PEEK Y_CONSTANT",
"D_XXX : '~'",
"script_params : proc_stmt var_decls begin_stmt",
"$$3 :",
"script_body : begin_stmt $$3 s_list opnl end_stmt",
"$$4 :",
"proc_stmt : Y_PROCEDURE $$4 param bparam_list EOST",
"bparam_list :",
"bparam_list : LP param_list RP",
"param_list :",
"param_list : xparam_list",
"xparam_list : param",
"xparam_list : xparam_list DELIM param",
"var_decls :",
"var_decls : var_decl_block",
"var_decl_block : var_decl_line",
"var_decl_block : var_decl_block var_decl_line",
"var_decl_line : EOST",
"var_decl_line : var_decl_stmt",
"var_decl_line : error NL",
"$$5 :",
"var_decl_stmt : typedefs $$5 var_decl_list EOST",
"typedefs : Y_BOOL",
"typedefs : Y_STRING",
"typedefs : Y_REAL",
"typedefs : Y_FILE",
"typedefs : Y_GCUR",
"typedefs : Y_IMCUR",
"typedefs : Y_UKEY",
"typedefs : Y_PSET",
"typedefs : Y_INT",
"typedefs : Y_STRUCT",
"var_decl_list : var_decl_plus",
"var_decl_list : var_decl_plus DELIM var_decl_list",
"var_decl_plus : var_decl",
"var_decl_plus : var_decl '{' options_list ';' '}'",
"var_decl : var_def",
"$$6 :",
"var_decl : var_def '=' $$6 init_list",
"var_def : var_name",
"$$7 :",
"var_def : var_name $$7 '[' init_index_list ']'",
"var_name : param",
"var_name : '*' param",
"init_index_list :",
"init_index_list : init_index_range",
"init_index_list : init_index_list DELIM init_index_range",
"init_index_range : const",
"init_index_range : const ':' const",
"init_list : init_elem",
"init_list : init_list DELIM init_elem",
"init_elem : const",
"init_elem : Y_CONSTANT LP const RP",
"const : Y_CONSTANT",
"const : number",
"number : sign Y_CONSTANT",
"sign : '+'",
"sign : '-'",
"options_list : init_list DELIM options",
"options_list : init_list",
"options_list : options",
"options : option",
"options : options DELIM option",
"option : Y_IDENT '=' const",
"begin_stmt : Y_BEGIN NL",
"expr : expr0",
"expr : ref",
"expr0 : expr1",
"expr0 : Y_CONSTANT",
"expr0 : Y_GCUR",
"expr0 : Y_IMCUR",
"expr0 : Y_UKEY",
"expr0 : Y_PSET",
"expr1 : LP expr RP",
"expr1 : expr '+' opnl expr",
"expr1 : expr '-' opnl expr",
"expr1 : expr '*' opnl expr",
"expr1 : expr '/' opnl expr",
"expr1 : expr YOP_POW opnl expr",
"expr1 : expr '%' opnl expr",
"expr1 : expr YOP_CONCAT opnl expr",
"expr1 : expr '<' opnl expr",
"expr1 : expr '>' opnl expr",
"expr1 : expr YOP_LE opnl expr",
"expr1 : expr YOP_GE opnl expr",
"expr1 : expr YOP_EQ opnl expr",
"expr1 : expr YOP_NE opnl expr",
"expr1 : expr YOP_OR opnl expr",
"expr1 : expr YOP_AND opnl expr",
"expr1 : YOP_NOT expr",
"expr1 : '-' expr",
"$$8 :",
"expr1 : Y_SCAN LP $$8 scanarg RP",
"$$9 :",
"expr1 : Y_SCANF LP $$9 scanfmt DELIM scanarg RP",
"$$10 :",
"expr1 : Y_FSCAN LP $$10 scanarg RP",
"$$11 :",
"expr1 : Y_FSCANF LP Y_IDENT DELIM $$11 scanfmt DELIM scanarg RP",
"$$12 :",
"expr1 : intrinsx LP $$12 intrarg RP",
"intrinsx : intrins",
"intrinsx : Y_INT",
"intrinsx : Y_REAL",
"scanfmt : expr",
"scanarg :",
"scanarg : Y_IDENT",
"scanarg : Y_IDENT DELIM scanarg",
"intrarg :",
"intrarg : expr",
"intrarg : intrarg DELIM expr",
"stmt : c_stmt",
"stmt : assign EOST",
"stmt : cmdlist EOST",
"stmt : immed EOST",
"stmt : inspect EOST",
"stmt : osesc EOST",
"stmt : popstk EOST",
"stmt : if",
"stmt : ifelse",
"stmt : iferr",
"stmt : iferr_else",
"stmt : while",
"stmt : for",
"stmt : switch",
"stmt : case",
"stmt : default",
"stmt : next EOST",
"stmt : break EOST",
"stmt : goto EOST",
"stmt : return EOST",
"stmt : label_stmt",
"stmt : nullstmt",
"c_stmt : c_blk",
"c_stmt : c_blk NL",
"$$13 :",
"$$14 :",
"c_blk : '{' $$13 s_list opnl $$14 '}'",
"s_list :",
"s_list : s_list opnl xstmt",
"assign : ref equals expr0",
"assign : ref equals ref",
"$$15 :",
"assign : ref $$15 assign_oper expr",
"equals : '='",
"assign_oper : YOP_AOADD",
"assign_oper : YOP_AOSUB",
"assign_oper : YOP_AOMUL",
"assign_oper : YOP_AODIV",
"assign_oper : YOP_AOCAT",
"$$16 :",
"cmdlist : command $$16 cmdpipe",
"cmdpipe :",
"$$17 :",
"cmdpipe : cmdpipe pipe $$17 command",
"pipe : '|' opnl",
"pipe : Y_ALLPIPE opnl",
"$$18 :",
"$$19 :",
"command : tasknam $$18 BARG $$19 args EARG",
"$$20 :",
"args : DELIM $$20 arglist",
"args : arglist",
"arglist : arg",
"arglist : arglist DELIM arg",
"arg :",
"arg : expr0",
"arg : ref",
"arg : ref '=' expr0",
"arg : ref '=' ref",
"arg : param '+'",
"arg : param '-'",
"arg : '<' file",
"arg : '>' file",
"arg : Y_ALLREDIR file",
"arg : Y_APPEND file",
"arg : Y_ALLAPPEND file",
"arg : Y_GSREDIR file",
"file : expr0",
"file : param",
"immed : equals expr0",
"immed : equals ref",
"inspect : ref equals",
"osesc : Y_OSESC",
"popstk : equals",
"iferr : iferr_stat",
"$$21 :",
"$$22 :",
"iferr_stat : iferr_tok $$21 c_blk $$22 op_then opnl xstmt",
"$$23 :",
"iferr_else : iferr_stat Y_ELSE $$23 opnl xstmt",
"iferr_tok : Y_IFERR",
"iferr_tok : Y_IFNOERR",
"op_then :",
"op_then : Y_THEN",
"if : if_stat",
"$$24 :",
"if_stat : Y_IF LP expr RP $$24 opnl xstmt",
"$$25 :",
"ifelse : if_stat Y_ELSE $$25 opnl xstmt",
"$$26 :",
"$$27 :",
"while : Y_WHILE LP $$26 expr RP $$27 opnl xstmt",
"$$28 :",
"$$29 :",
"$$30 :",
"for : Y_FOR LP opnl xassign ';' opnl $$28 xexpr ';' opnl $$29 xassign RP opnl $$30 stmt",
"xassign : assign",
"xassign :",
"xexpr : expr",
"xexpr :",
"$$31 :",
"switch : Y_SWITCH opnl LP opnl expr opnl RP opnl $$31 xstmt",
"$$32 :",
"$$33 :",
"case : Y_CASE $$32 const_expr_list ':' opnl $$33 xstmt",
"$$34 :",
"default : Y_DEFAULT ':' opnl $$34 xstmt",
"next : Y_NEXT",
"break : Y_BREAK",
"return : Y_RETURN",
"return : Y_RETURN expr",
"end_stmt : Y_END NL",
"$$35 :",
"label_stmt : Y_IDENT ':' opnl $$35 xstmt",
"goto : Y_GOTO Y_IDENT",
"nullstmt : ';'",
"nullstmt : ';' NL",
"$$36 :",
"xstmt : $$36 stmt",
"xstmt : var_decl_stmt",
"xstmt : error NL",
"const_expr_list : const_expr",
"const_expr_list : const_expr DELIM const_expr_list",
"const_expr : const",
"opnl :",
"opnl : NL",
"ref : param",
"$$37 :",
"ref : param $$37 '[' index_list ']'",
"index_list : index",
"$$38 :",
"index_list : index $$38 DELIM index_list",
"index : expr1",
"index : ref",
"index : '*'",
"index : Y_CONSTANT",
"intrins : Y_IDENT",
"param : Y_IDENT",
"tasknam : Y_IDENT",
"EOST : NL",
"EOST : ';'",
"DELIM : ','",
"BARG :",
"BARG : LP",
"EARG :",
"EARG : RP",
"LP : '('",
"RP : ')'",
"NL : Y_NEWLINE",
};
#endif
#ifndef YYSTYPE
typedef int YYSTYPE;
#endif
#if YYDEBUG
#include <stdio.h>
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH 10000
#endif
#endif
#define YYINITSTACKSIZE 200
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short *yyss;
short *yysslim;
YYSTYPE *yyvs;
int yystacksize;
#line 2106 "grammar.y"

#include "lexyy.c"
#include "lexicon.c"
#line 1286 "y.tab.c"
/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack()
{
    int newsize, i;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = yystacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;
    i = yyssp - yyss;
    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
      (short *)malloc(newsize * sizeof *newss);
    if (newss == NULL)
        return -1;
    yyss = newss;
    yyssp = newss + i;
    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
      (YYSTYPE *)malloc(newsize * sizeof *newvs);
    if (newvs == NULL)
        return -1;
    yyvs = newvs;
    yyvsp = newvs + i;
    yystacksize = newsize;
    yysslim = yyss + newsize - 1;
    return 0;
}

#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab

#ifndef YYPARSE_PARAM
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG void
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG
#define YYPARSE_PARAM_DECL
#endif	/* ANSI-C/C++ */
#else	/* YYPARSE_PARAM */
#ifndef YYPARSE_PARAM_TYPE
#define YYPARSE_PARAM_TYPE void *
#endif
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
#endif	/* ANSI-C/C++ */
#endif	/* ! YYPARSE_PARAM */

int
yyparse (YYPARSE_PARAM_ARG)
    YYPARSE_PARAM_DECL
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register const char *yys;

    if ((yys = getenv("YYDEBUG")))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    if (yyss == NULL && yygrowstack()) goto yyoverflow;
    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if ((yyn = yydefred[yystate])) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yysslim && yygrowstack())
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#if defined(lint) || defined(__GNUC__)
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#if defined(lint) || defined(__GNUC__)
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yysslim && yygrowstack())
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
#line 144 "grammar.y"
{
		    /* Done once on entry but after at least one call to
		     * yylex().  Good for initing parser flags.
		     * Note: this does not get called in procedure scripts.
		     */
		    if (cldebug)
			eprintf ("parse init (block)...\n");

		    errcnt     = 0;
		    err_cmdblk = 0;
		    dobkg      = 0;
		    inarglist  = 0;
		    parenlevel = 0;
		    bracelevel = 0;
		    tbrace     = 0;
		    dobrace    = 0;
		    in_iferr   = 0;
		    do_params  = YES;
		    last_parm  = NULL;
		    ifseen     = NULL;
		    label1     = NULL;
		    errmsg     = NULL;
		    parse_pfile= currentask->t_pfp;
		}
break;
case 2:
#line 169 "grammar.y"
{
		    /* Prepare to rerun whatever was compiled last.
		     * Does not work for the debug commands builtin here.
		     */
		    if (parse_state != PARSE_FREE) {
			errmsg = "Illegal parser state.";
			EYYERROR;
		    }
		    rerun();
		    YYACCEPT;
		}
break;
case 3:
#line 181 "grammar.y"
{
		    if (parse_state == PARSE_PARAMS) {
			errmsg = "Illegal parser state.";
			EYYERROR;
		    }
		}
break;
case 4:
#line 187 "grammar.y"
{
		    if (sawnl && bracelevel == 0) {
			if (!errcnt)
			    compile (END);
			if (ifseen) {
			    /* Simulate an unput of what has been read
			     * from the current line.
			     */
			    ip_cmdblk = ifseen;
			}
			YYACCEPT;
		    }
		}
break;
case 5:
#line 201 "grammar.y"
{
		    /* Parse the parameters in a script file.  This will
		     * normally be done on a call by pfileread().
		     */
		    if (parse_state != PARSE_PARAMS) {
			eprintf ("Illegal parser state.\n");
			errcnt++;
		    }
		    YYACCEPT;
		}
break;
case 6:
#line 212 "grammar.y"
{
		    /* Parse the executable statements in a script.
		     */
		    if (parse_state != PARSE_BODY) {
			eprintf ("Illegal parser state.\n");
			errcnt++;
		    }
		    if (!errcnt)
			compile (END);
		    YYACCEPT;
		}
break;
case 7:
#line 224 "grammar.y"
{
		    /* This catches errors that the two other error lines
		     * can't get, e.g. a missing `}' at the end of a script, 
		     * or errors occuring in interactive input.
		     */
		    yyerrok;

		    /* Discard everything and compile a null statement.
		     */
		    if (!errcnt) {
			do_params = YES;
			pc = currentask->t_bascode;
			if (parse_state != PARSE_PARAMS)
			    compile (END);

			topd = currentask->t_topd;
			topcs = currentask->t_topcs;

			/* Unlink any added parms.  Resetting of topd will
			 * already have reclaimed space.
			 */
			if (last_parm) {
			    last_parm->p_np = NULL;
			    currentask->t_pfp->pf_lastpp = last_parm;
			    last_parm = NULL;
			}
	 	    }

		    /* Print cmdblk and show position of error.
		     */
		    p_position();
		    if (currentask->t_flags & T_SCRIPT) 
			cl_error (E_UERR, "syntax error, line %d",
			    currentask->t_scriptln);
		    else
			cl_error (E_UERR, "syntax error");

		    YYACCEPT;
		}
break;
case 9:
#line 266 "grammar.y"
{
		    /* debug are those debugging functions that
		     * should be run directly and not through a
		     * builtin task due to stack or other changes,
		     * ie, don't change what we are trying to show.
		     */
		    printf ("\n");
		}
break;
case 11:
#line 276 "grammar.y"
{
		    d_d(); /* show dictionary/stack pointers */
		}
break;
case 12:
#line 279 "grammar.y"
{ /* show a dictionary location	*/
		    if (stkop(yyvsp[0])->o_type & OT_INT) {
			int	idx;
			idx = stkop(yyvsp[0])->o_val.v_i;
			eprintf ("%d:\t%d (0%o)\n", idx, stack[idx],
				stack[idx]);
		    } else
			eprintf ("usage: D_PEEK <d. index>\n");
		}
break;
case 13:
#line 288 "grammar.y"
{
		    d_stack (pc, 0, 0);		/* show compiled code	*/
		}
break;
case 14:
#line 295 "grammar.y"
{ 
			/* Check for required params.
			 */
			if (!errcnt)
			    proc_params(n_procpar);
		}
break;
case 15:
#line 303 "grammar.y"
{
			/* Initialize parser for procedure body.
			 */
			if (cldebug)
			    eprintf ("parse init (script_body)...\n");

			errcnt     = 0;
			err_cmdblk = 0;
			dobkg      = 0;
			inarglist  = 0;
			parenlevel = 0;
		        in_iferr   = 0;
			dobrace    = 0;
			bracelevel = PBRACE; /* disable lexmodes; force "end" */
			tbrace     = 0;
 			do_params  = NO;
			last_parm  = NULL;
			ifseen     = NULL;
			label1     = NULL;
			parse_pfile= currentask->t_pfp;
		}
break;
case 17:
#line 329 "grammar.y"
{  
			/* Initialize parser for procedure parameters.
			 */
			if (cldebug)
			    eprintf ("parse init (proc_stmt)...\n");

			errcnt     = 0;
			err_cmdblk = 0;
			dobkg      = 0;
			inarglist  = 0;
			parenlevel = 0;
			bracelevel = PBRACE;
			tbrace     = 0;
		        dobrace    = 0;
		        in_iferr   = 0;
			do_params  = YES;
		        last_parm  = NULL;
			label1     = NULL;
		}
break;
case 19:
#line 352 "grammar.y"
{
		    n_procpar = 0;
		}
break;
case 21:
#line 361 "grammar.y"
{
		    n_procpar = 0;
		}
break;
case 23:
#line 367 "grammar.y"
{ 
		    n_procpar = 1;
		    if (!errcnt)
			push (stkop(yyvsp[0]));
		}
break;
case 24:
#line 372 "grammar.y"
{
		    n_procpar++;
		    if (!errcnt)
			push (stkop(yyvsp[0]));
		}
break;
case 31:
#line 389 "grammar.y"
{
		    /* This catches errors in the parameter declarations
		     * of a procedure script.
		     */
		    yyerrok;

		    /* Discard everything and compile a null statement.
		     */
		    if (!errcnt) {
			do_params = YES;
			pc = currentask->t_bascode;
			if (parse_state != PARSE_PARAMS)
			    compile (END);

			topd = currentask->t_topd;
			topcs = currentask->t_topcs;

			/* Unlink any added parms.  Resetting of topd will
			 * already have reclaimed space.
			 */
			if (last_parm) {
			    last_parm->p_np = NULL;
			    currentask->t_pfp->pf_lastpp = last_parm;
			    last_parm = NULL;
			}
	 	    }

		    /* Print cmdblk and show position of error.  We know
		     * we're parsing a procedure script, so print the line
		     * number too.
		     */
		    p_position();
		    cl_error (E_UERR, "syntax error, line %d", 
			currentask->t_scriptln);
		}
break;
case 32:
#line 426 "grammar.y"
{
	 	        /* For in-line definitions we don't want
			 * to freeze stuff on the dictionary, so
			 * only allow additions if the dictionary
			 * is the same as at the beginning of the task.
			 */
			if (!errcnt) {
			    if (parse_state != PARSE_PARAMS) {
				if (currentask->t_topd != topd)
				    cl_error (E_UERR, illegalvar);
				last_parm = currentask->t_pfp->pf_lastpp;
			    }
			}

		        /* Increment bracelevel temporarily to defeat command
			 * mode, in case this is an in-line declaration and
			 * lexmodes=yes.
			 */
			bracelevel += PBRACE;
			tbrace++;

		}
break;
case 33:
#line 447 "grammar.y"
{
		      	/* Update dictionary to include these definitions.
			 */
			if (!errcnt) {
			    if (parse_state != PARSE_PARAMS) {
				currentask->t_topd = topd;
				last_parm = 0;
			    }
			}

			/* Restore command mode */
			bracelevel -= PBRACE;
			tbrace--;
		}
break;
case 34:
#line 463 "grammar.y"
{ vartype = V_BOOL; }
break;
case 35:
#line 464 "grammar.y"
{ vartype = V_STRING; }
break;
case 36:
#line 465 "grammar.y"
{ vartype = V_REAL; }
break;
case 37:
#line 466 "grammar.y"
{ vartype = V_FILE; }
break;
case 38:
#line 467 "grammar.y"
{ vartype = V_GCUR; }
break;
case 39:
#line 468 "grammar.y"
{ vartype = V_IMCUR; }
break;
case 40:
#line 469 "grammar.y"
{ vartype = V_UKEY; }
break;
case 41:
#line 470 "grammar.y"
{ vartype = V_PSET; }
break;
case 42:
#line 471 "grammar.y"
{ vartype = V_INT; }
break;
case 43:
#line 472 "grammar.y"
{ vartype = V_STRUCT; }
break;
case 46:
#line 479 "grammar.y"
{
			if (!errcnt) {
			    if (pp != NULL) {
				if (n_aval > 1)
				    pp->p_type |= PT_ARRAY;

				if (pp->p_type & PT_ARRAY)
				    do_arrayinit (pp, n_aval, index_cnt);
		      		else
		 		    do_scalarinit (pp, inited);
			    }
			}
		}
break;
case 47:
#line 497 "grammar.y"
{
			if (!errcnt) {
			    if (pp != NULL) {
				if (!do_params)
				    cl_error (E_UERR, badparm, pp->p_name);

				if (n_aval > 1)
				    pp->p_type |= PT_ARRAY;

				if (pp->p_type & PT_ARRAY)
				    do_arrayinit (pp, n_aval, index_cnt);
		      		else
		 		    do_scalarinit (pp, n_aval);
			    }
			}
		}
break;
case 48:
#line 515 "grammar.y"
{
			inited = NO;
			n_aval = 0;
		}
break;
case 49:
#line 519 "grammar.y"
{
			n_aval = 0;
		}
break;
case 50:
#line 522 "grammar.y"
{
			inited = YES;
		}
break;
case 51:
#line 527 "grammar.y"
{
		    index_cnt = 0;
		    if (!errcnt)
			pp = initparam (stkop(yyvsp[0]), do_params, vartype, varlist);
		}
break;
case 52:
#line 532 "grammar.y"
{
		    int  itemp;

		    if (!errcnt) {
			pp = initparam (stkop(yyvsp[0]), do_params, vartype, varlist);

			if (pp != NULL) {
			    itemp = (pp->p_type & OT_BASIC) == pp->p_type;
			    itemp = itemp && !varlist;
			    if (itemp)
				pp->p_type |= PT_ARRAY;
			    else
				cl_error (E_UERR, inval_arr, pp->p_name);
			}
		    }
		}
break;
case 54:
#line 551 "grammar.y"
{
			varlist = NO;
			index_cnt = 0;
		}
break;
case 55:
#line 555 "grammar.y"
{
			if (!do_params) {
			    errmsg = locallist;
			    EYYERROR;
			}
			varlist = YES;
			index_cnt = 0;
			yyval = yyvsp[0];
		}
break;
case 59:
#line 575 "grammar.y"
{
		    if (!errcnt) {
			if (pp != NULL) {
			    if (stkop(yyvsp[0])->o_type == OT_INT) {
				push (stkop(yyvsp[0])->o_val.v_i);
				push (1);
			    } else if (maybeindex) {
				/* Confusion between sexagesimal and index
				 * range.  Maybeindex is set only when operand
				 * is real.
			 	 */
				int  i1,i2;
				sexa_to_index (stkop(yyvsp[0])->o_val.v_r, &i1, &i2);
				push (i2-i1+1);
				push (i1);
			    } else {
				eprintf (inv_index, pp->p_name);
				EYYERROR;
			    }
			    index_cnt++;
			}
		    }
		}
break;
case 60:
#line 598 "grammar.y"
{
			if (!errcnt) {
			    if (pp != NULL) {
				if (stkop(yyvsp[-2])->o_type != OT_INT  ||
				    stkop(yyvsp[0])->o_type != OT_INT)
				    cl_error (E_UERR, inv_index, pp->p_name);
				else {
				    push (stkop(yyvsp[0])->o_val.v_i -
				          stkop(yyvsp[-2])->o_val.v_i + 1);
				    push (stkop(yyvsp[-2])->o_val.v_i);
			        }
			        index_cnt++;
			    }
			}
		}
break;
case 63:
#line 619 "grammar.y"
{
			if (!errcnt) {
			    if (pp != NULL) {
				push (stkop(yyvsp[0]) );
				n_aval++;
			    }
			}
		}
break;
case 64:
#line 628 "grammar.y"
{
			int   cnt;
			
			if (!errcnt)
			    if (pp != NULL) {
			    	if (stkop(yyvsp[-3])->o_type != OT_INT)
				    cl_error (E_UERR, arrdeferr, pp->p_name);

			        cnt = stkop(yyvsp[-3])->o_val.v_i;
			        if (cnt <= 0)
				    cl_error (E_UERR, arrdeferr, pp->p_name);

			        while (cnt-- > 0) {
				    push (stkop(yyvsp[-1]));
				    n_aval++;
			        }
			    }
		}
break;
case 67:
#line 655 "grammar.y"
{
		      	if (stkop(yyvsp[0])->o_type == OT_INT) {
			    stkop(yyvsp[0])->o_val.v_i *= yyvsp[-1];
			    yyval = yyvsp[0];
			} else if (stkop(yyvsp[0])->o_type == OT_REAL) {
			    stkop(yyvsp[0])->o_val.v_r *= yyvsp[-1];
			    yyval = yyvsp[0];
			} else {
			    errmsg = "Invalid constant in declaration.";
			    EYYERROR;
			}
		}
break;
case 68:
#line 669 "grammar.y"
{ yyval =  1; }
break;
case 69:
#line 670 "grammar.y"
{ yyval = -1; }
break;
case 70:
#line 672 "grammar.y"
{
			/* Check if we already had an initialization. 
			 */
		      	if (!errcnt) {
			    if (inited && pp != NULL) {
				eprintf (twoinits, pp->p_name);
				EYYERROR;
			    }
			}
		}
break;
case 71:
#line 682 "grammar.y"
{
		      	if (!errcnt) {
			    if (inited && pp != NULL) {
			        eprintf (twoinits, pp->p_name);
				EYYERROR;
			    }
			}
		}
break;
case 75:
#line 697 "grammar.y"
{
			if (!errcnt)
			    if (pp != NULL)
			    	do_option (pp, stkop(yyvsp[-2]), stkop(yyvsp[0]));
		}
break;
case 78:
#line 713 "grammar.y"
{
		    if (!errcnt)
		        compile (PUSHPARAM, stkop(yyvsp[0])->o_val.v_s);
		}
break;
case 80:
#line 727 "grammar.y"
{
		    if  (!errcnt)
		        compile (PUSHCONST, stkop(yyvsp[0]));
		}
break;
case 81:
#line 731 "grammar.y"
{
		    /* "gcur" is both a keyword and a CL global parameter,
		     * and must be built into the grammar here to permit
		     * reference of the parameter in expressions.
		     */
		    if (!errcnt)
			compile (PUSHPARAM, "gcur");
		}
break;
case 82:
#line 739 "grammar.y"
{
		    if (!errcnt)
			compile (PUSHPARAM, "imcur");
		}
break;
case 83:
#line 743 "grammar.y"
{
		    if (!errcnt)
			compile (PUSHPARAM, "ukey");
		}
break;
case 84:
#line 747 "grammar.y"
{
		    if (!errcnt)
			compile (PUSHPARAM, "pset");
		}
break;
case 86:
#line 755 "grammar.y"
{
		    if (!errcnt)
			compile (ADD);
		}
break;
case 87:
#line 759 "grammar.y"
{
		    if (!errcnt)
			compile (SUB);
		}
break;
case 88:
#line 763 "grammar.y"
{
		    if (!errcnt)
			compile (MUL);
		}
break;
case 89:
#line 767 "grammar.y"
{
		    if (!errcnt)
			compile (DIV);
		}
break;
case 90:
#line 771 "grammar.y"
{
		    if (!errcnt)
			compile (POW);
		}
break;
case 91:
#line 775 "grammar.y"
{
		    struct	operand o;
		    if (!errcnt) {
			o.o_type = OT_INT;
			o.o_val.v_i = 2;
			compile (PUSHCONST, &o);
			compile (INTRINSIC, "mod");
		    }
		}
break;
case 92:
#line 784 "grammar.y"
{
		    if (!errcnt)
			compile (CONCAT);
		}
break;
case 93:
#line 788 "grammar.y"
{
		    if (!errcnt)
			compile (LT);
		}
break;
case 94:
#line 792 "grammar.y"
{
		    if (!errcnt)
			compile (GT);
		}
break;
case 95:
#line 796 "grammar.y"
{
		    if (!errcnt)
			compile (LE);
		}
break;
case 96:
#line 800 "grammar.y"
{
		    if (!errcnt)
			compile (GE);
		}
break;
case 97:
#line 804 "grammar.y"
{
		    if (!errcnt)
			compile (EQ);
		}
break;
case 98:
#line 808 "grammar.y"
{
		    if (!errcnt)
			compile (NE);
		}
break;
case 99:
#line 812 "grammar.y"
{
		    if (!errcnt)
			compile (OR);
		}
break;
case 100:
#line 816 "grammar.y"
{
		    if (!errcnt)
			compile (AND);
		}
break;
case 101:
#line 820 "grammar.y"
{
		    if (!errcnt)
			compile (NOT);
		}
break;
case 102:
#line 824 "grammar.y"
{
		    if (!errcnt)
			compile (CHSIGN);
		}
break;
case 103:
#line 829 "grammar.y"
{
		    /* Free format scan. */
		    if (!errcnt)
			push (0);	/* use control stack to count args */
		}
break;
case 104:
#line 833 "grammar.y"
{
		    if (!errcnt) {
			struct	operand o;
			o.o_type = OT_INT;
		        o.o_val.v_i = pop();	/* get total number of args*/
			compile (PUSHCONST, &o);
			compile (SCAN);
		    }
		}
break;
case 105:
#line 842 "grammar.y"
{
		    /* Formatted scan. */
		    if (!errcnt)
			push (0);	/* use control stack to count args */
		}
break;
case 106:
#line 846 "grammar.y"
{
		    if (!errcnt) {
			struct	operand o;

			/* Compile number of arguments. */
			o.o_type = OT_INT;
		        o.o_val.v_i = pop();
			compile (PUSHCONST, &o);

			compile (SCANF);
		    }
		}
break;
case 107:
#line 859 "grammar.y"
{
		    /* Free format scan from a parameter.  */
		    if (!errcnt)
			push (0);	/* use control stack to count args */
		}
break;
case 108:
#line 863 "grammar.y"
{
		    if (!errcnt) {
			struct	operand o;
			o.o_type = OT_INT;
			o.o_val.v_i = pop();	/* get total number of args*/
			compile (PUSHCONST, &o);
			compile (FSCAN);
		    }
		}
break;
case 109:
#line 873 "grammar.y"
{
		    /* Formatted scan from a parameter.
		     * fscanf (param, format, arg1, ...)
		     */
		    if (!errcnt) {
			compile (PUSHCONST, stkop (yyvsp[-1]));
		        push (1);	/* use control stack to count args */
		    }
		}
break;
case 110:
#line 881 "grammar.y"
{
		    if (!errcnt) {
			struct	operand o;

			/* Compile number of arguments. */
			o.o_type = OT_INT;
			o.o_val.v_i = pop();
			compile (PUSHCONST, &o);

			compile (FSCANF);
		    }
		}
break;
case 111:
#line 894 "grammar.y"
{
		    if (!errcnt)
			push (0);	/* use control stack to count args */
		}
break;
case 112:
#line 897 "grammar.y"
{
		    if (!errcnt) {
			struct	operand o;
			o.o_type = OT_INT;
			o.o_val.v_i = pop();
			compile (PUSHCONST, &o);
			compile (INTRINSIC, stkop(yyvsp[-4])->o_val.v_s);
		    }
		}
break;
case 114:
#line 912 "grammar.y"
{
			/* The YACC value of this must match normal intrinsics
			 * so we must generate an operand with the proper
			 * string. 
			 */
			if (!errcnt)
			    yyval = addconst ("int", OT_STRING);
		}
break;
case 115:
#line 920 "grammar.y"
{
			if (!errcnt)
			    yyval = addconst ("real", OT_STRING);
		}
break;
case 116:
#line 926 "grammar.y"
{
		    if (!errcnt) {
		        push (pop() + 1);		/* inc num args	*/
		    }
		}
break;
case 118:
#line 939 "grammar.y"
{
                    if (!errcnt) {
                        compile (PUSHCONST, stkop (yyvsp[0]));
                        push (pop() + 1);               /* inc num args */
                    }
		}
break;
case 119:
#line 945 "grammar.y"
{
                    if (!errcnt) {
                        compile (PUSHCONST, stkop (yyvsp[-2]));
                        push (pop() + 1);               /* inc num args */
                    }
		}
break;
case 121:
#line 956 "grammar.y"
{
		    if (!errcnt)
			push (pop() + 1);		/* inc num args	*/
		}
break;
case 122:
#line 960 "grammar.y"
{
		    if (!errcnt)
			push (pop() + 1);		/* inc num args	*/
		}
break;
case 147:
#line 1000 "grammar.y"
{
		    bracelevel++;
		}
break;
case 148:
#line 1002 "grammar.y"
{
		    --bracelevel;
		}
break;
case 152:
#line 1014 "grammar.y"
{
			--parenlevel;
 			if (!errcnt)
		      	    compile (ASSIGN, stkop(yyvsp[-2])->o_val.v_s);
		}
break;
case 153:
#line 1019 "grammar.y"
{
			/* Old code pushed a constant rather than a param
			 * when not within braces.  This doesn't seem
			 * to be what most people want.
			 */
			--parenlevel;
			if (!errcnt) {
			    compile (PUSHPARAM, stkop(yyvsp[0])->o_val.v_s);
		            compile (ASSIGN, stkop(yyvsp[-2])->o_val.v_s);
		    	}
		}
break;
case 154:
#line 1030 "grammar.y"
{
			parenlevel++;
		}
break;
case 155:
#line 1033 "grammar.y"
{
		      	--parenlevel;
			if (!errcnt)
		  	    compile (yyvsp[-1], stkop(yyvsp[-3])->o_val.v_s);
		}
break;
case 156:
#line 1042 "grammar.y"
{
			parenlevel++;
		}
break;
case 157:
#line 1047 "grammar.y"
{ yyval = ADDASSIGN; }
break;
case 158:
#line 1048 "grammar.y"
{ yyval = SUBASSIGN; }
break;
case 159:
#line 1049 "grammar.y"
{ yyval = MULASSIGN; }
break;
case 160:
#line 1050 "grammar.y"
{ yyval = DIVASSIGN; }
break;
case 161:
#line 1051 "grammar.y"
{ yyval = CATASSIGN; }
break;
case 162:
#line 1054 "grammar.y"
{
		    npipes = 0;
		}
break;
case 163:
#line 1056 "grammar.y"
{
		    if (!errcnt) {
			compile (EXEC);
			if (npipes > 0)
			    compile (RMPIPES, npipes);
		    }
		}
break;
case 165:
#line 1066 "grammar.y"
{
		    /* Pipefiles must be allocated at run time using a stack
		     * to permit pipe commands within loops, and to permit
		     * scripts called in a pipe to themselves contain pipe
		     * commands.  ADDPIPE allocates a new pipefile on the
		     * pipe stack and pushes its name on the operand stack.
		     * GETPIPE pushes the pipefile at the top of the pipe
		     * stack onto the operand stack.  RMPIPES removes N pipes
		     * from the pipe stack, and deletes the physical pipefiles.
		     */

		    if (!newstdout) {
			/* When the runtime code creates the pipe it needs to
			 * know the identity of the two tasks sharing the pipe
			 * to determine what type of pipe to create (text or
			 * binary).  Save the pc of the ADDPIPE instruction
			 * so that we can backpatch it below with a pointer to
			 * the name of the second task in the pipe (ADDPIPE
			 * will be called during startup of the first task
			 * hence will know its name).
			 */
			pipe_pc = compile (ADDPIPE, NULL);

			if (yyvsp[0] == 1)
			    compile (REDIR);
			else
			    compile (ALLREDIR);
			compile (EXEC);

		    } else {
			eprintf ("multiple redirection\n");
			YYERROR;
		    }

		}
break;
case 166:
#line 1100 "grammar.y"
{
		    /* Compile the GETPIPE instruction with the name of the
		     * second task in the current pipe, and backpatch the
		     * matching ADDPIPE instruction with the PC of the GETPIPE.
		     */
		    (coderef(pipe_pc))->c_args = compile (GETPIPE, curr_task);
		    compile (REDIRIN);
		    npipes++;		/* Overflow checking is in ADDPIPE */
		}
break;
case 167:
#line 1111 "grammar.y"
{
		    yyval = 1;
		}
break;
case 168:
#line 1114 "grammar.y"
{
		    yyval = 2;
		}
break;
case 169:
#line 1119 "grammar.y"
{
		    char    *ltname;

		    ltname = stkop(yyvsp[0])->o_val.v_s;
		    compile (CALL, ltname);
		    strcpy (curr_task, ltname);

		    /* The FPRINT task is special; the first arg
		     * is the destination and must be compiled as
		     * a string constant no matter what.  Set flag
		     * so that 'arg' compiles PUSHCONST.
		     */
		    printstmt = (strcmp (ltname, "fprint") == 0);

		    /* Ditto with SCAN; all the arguments are call by
		     * reference and must be compiled as string constants.
		     */
		    scanstmt = (strcmp (ltname, "scan") == 0 ||
				strcmp (ltname, "scanf") == 0);

		    absmode = 0;
		    posit = 0;
		    newstdout = 0;
		    parenlevel = 0;
		}
break;
case 170:
#line 1143 "grammar.y"
{
		    inarglist = 1;
		}
break;
case 171:
#line 1145 "grammar.y"
{
		    extern char *onerr_handler;

		    inarglist = 0;
		    parenlevel = 0;
		    scanstmt = 0;
		}
break;
case 172:
#line 1154 "grammar.y"
{
		    /* (,x) equates to nargs == 2.  Call posargset with
		     * negative dummy argument to bump nargs.
		     */
		    if (!errcnt) {
			compile (POSARGSET, -1);
			posit++;
			printstmt = 0;
			scanstmt = 0;
		    }
		}
break;
case 177:
#line 1173 "grammar.y"
{
		    if (!errcnt) {
			if (posit > 0) {		/* not first time */
			    compile (POSARGSET, -posit);
			    printstmt = 0;
			    scanstmt = 0;
			}
			posit++;
		    }
		}
break;
case 178:
#line 1183 "grammar.y"
{
		    if (absmode) {
			errmsg = posfirst;
			EYYERROR;
		    } else
			if (!errcnt)
			    compile (POSARGSET, posit++);
		}
break;
case 179:
#line 1191 "grammar.y"
{
		    if (absmode) {
			errmsg = posfirst;
			EYYERROR;
		    } else if (!errcnt) {
			if (scanstmt) {
			    char    pname[SZ_FNAME];
			    char    *pk, *t, *p, *f;
			    struct  pfile *pfp;
			    struct  operand o;

			    /* If no task name specified check the pfile for
			     * the task containing the scan statement for the
			     * named parameter.
			     */
			    breakout (stkop(yyvsp[0])->o_val.v_s, &pk, &t, &p, &f);
			    pfp = currentask->t_pfp;
			    if (*pk == NULL && *t == NULL &&
				pfp && paramfind(pfp,p,0,1)) {

				sprintf (pname, "%s.%s",
				    currentask->t_ltp->lt_lname, p);
				if (*f) {
				    strcat (pname, ".");
				    strcat (pname, f);
				}
			    } else
				strcpy (pname, stkop(yyvsp[0])->o_val.v_s);

			    o = *(stkop(yyvsp[0]));
			    o.o_val.v_s = pname;
			    compile (PUSHCONST, &o);
			    compile (INDIRPOSSET, posit++);

			} else if (parenlevel == 0 || printstmt) {
			    compile (PUSHCONST, stkop(yyvsp[0]));
			    compile (INDIRPOSSET, posit++);
			    /* only first arg of fprint stmt is special. */
			    printstmt = 0;

			} else {
			    compile (PUSHPARAM, stkop(yyvsp[0])->o_val.v_s);
			    compile (POSARGSET, posit++);
			}
		    }
		}
break;
case 180:
#line 1237 "grammar.y"
{
		    absmode++;
		    if (!errcnt)
			compile (ABSARGSET, stkop(yyvsp[-2])->o_val.v_s); 
		}
break;
case 181:
#line 1242 "grammar.y"
{
		    absmode++;
		    if (!errcnt) {
			if (parenlevel == 0) {
			    compile (PUSHCONST, stkop(yyvsp[0]));
			    compile (INDIRABSSET, stkop(yyvsp[-2])->o_val.v_s); 
			} else {
			    compile (PUSHPARAM, stkop(yyvsp[0])->o_val.v_s);
			    compile (ABSARGSET, stkop(yyvsp[-2])->o_val.v_s);
			}
		    }
		}
break;
case 182:
#line 1254 "grammar.y"
{
		    absmode++;
		    if (!errcnt)
			compile (SWON, stkop(yyvsp[-1])->o_val.v_s);
		}
break;
case 183:
#line 1259 "grammar.y"
{
		    absmode++;
		    if (!errcnt)
			compile (SWOFF, stkop(yyvsp[-1])->o_val.v_s);
		}
break;
case 184:
#line 1264 "grammar.y"
{
		    if (!errcnt)
			compile (REDIRIN);
		}
break;
case 185:
#line 1268 "grammar.y"
{
		    newstdout++;
		    if (!errcnt)
			compile (REDIR);
		}
break;
case 186:
#line 1273 "grammar.y"
{
		    newstdout++;
		    if (!errcnt)
			compile (ALLREDIR);
		}
break;
case 187:
#line 1278 "grammar.y"
{
		    newstdout++;
		    if (!errcnt)
			compile (APPENDOUT);
		}
break;
case 188:
#line 1283 "grammar.y"
{
		    newstdout++;
		    if (!errcnt)
			compile (ALLAPPEND);
		}
break;
case 189:
#line 1288 "grammar.y"
{
		    if (!errcnt)
			compile (GSREDIR, stkop(yyvsp[-1])->o_val.v_s);
		}
break;
case 190:
#line 1294 "grammar.y"
{
		    absmode++;
		    /* constant already pushed by expr0.
		     */
		}
break;
case 191:
#line 1299 "grammar.y"
{
		    absmode++;
		    if (!errcnt) {
			if (parenlevel == 0)
			    compile (PUSHCONST, stkop(yyvsp[0]));
			else
			    compile (PUSHPARAM, stkop(yyvsp[0])->o_val.v_s);
			}
		}
break;
case 192:
#line 1310 "grammar.y"
{
			--parenlevel;
			if (!errcnt)
			    compile (IMMED);
		}
break;
case 193:
#line 1315 "grammar.y"
{
		      	--parenlevel;
			if (!errcnt)
			    compile (INSPECT, stkop(yyvsp[0])->o_val.v_s);
		}
break;
case 194:
#line 1322 "grammar.y"
{
			--parenlevel;
			if (!errcnt)
			    compile (INSPECT, stkop(yyvsp[-1])->o_val.v_s);
		}
break;
case 195:
#line 1329 "grammar.y"
{
		    if (!errcnt)
			compile (OSESC, stkop(yyvsp[0])->o_val.v_s);
		}
break;
case 196:
#line 1335 "grammar.y"
{
		    --parenlevel;
		    if (!errcnt)
			compile (IMMED);
		}
break;
case 197:
#line 1345 "grammar.y"
{
		    /* pop BIFF addr and set branch to just after statement */
		    if (!errcnt) {
		        int   biffaddr = pop();
		    	coderef (biffaddr)->c_args = pc - biffaddr - SZ_CE;
		    }
		    in_iferr = 0;
		}
break;
case 198:
#line 1355 "grammar.y"
{
		    if (++in_iferr > 1) { 
			errmsg = nestediferr; 
			EYYERROR; 
		    } 
		    compile (CALL, "_errpsh");
		    compile (EXEC);

		}
break;
case 199:
#line 1363 "grammar.y"
{
		    if (!errcnt) {
			struct	operand o;

			o.o_type = OT_INT;
			o.o_val.v_i = 0;
			compile (PUSHCONST, &o);       /* if (_errpop() != 0) */
			compile (INTRINSIC, "_errpop");
			compile (PUSHCONST, &o);
			compile (((iferr_tok == 0) ? NE : EQ));
			push (compile (BIFF, 0));
		    }
		}
break;
case 200:
#line 1375 "grammar.y"
{
		    in_iferr--;
		}
break;
case 201:
#line 1380 "grammar.y"
{
		    if (!errcnt) {
			/* Pop and save BIFF address, compile and push addr 
			 * of GOTO, and set BIFF branch to just after GOTO.
			 */
			int  biffaddr = pop();
			push (compile (GOTO, 0));
			coderef (biffaddr)->c_args = pc - biffaddr - SZ_CE;
		    }

		}
break;
case 202:
#line 1390 "grammar.y"
{
		    if (!errcnt) {
			/* Pop GOTO addr and set branch to just after statement
			 */
		    	int  gotoaddr = pop();
			coderef (gotoaddr)->c_args = pc - gotoaddr - SZ_CE;
		    }
		}
break;
case 203:
#line 1400 "grammar.y"
{ iferr_tok = 0; }
break;
case 204:
#line 1401 "grammar.y"
{ iferr_tok = 1; }
break;
case 207:
#line 1412 "grammar.y"
{
		    /* pop BIFF addr and set branch to just after statement
		     */
		    int   biffaddr;
		    if (!errcnt) {
			biffaddr = pop();
		    	coderef (biffaddr)->c_args = pc - biffaddr - SZ_CE;
		    }
		}
break;
case 208:
#line 1423 "grammar.y"
{
			/* save BIFF addr so branch can be filled in 
			 */
			if (!errcnt)
			    push (compile (BIFF, 0));
		}
break;
case 209:
#line 1428 "grammar.y"
{
			/* The shift/reduce conflict in the IF-IF/ELSE
			 * construct can cause errors in compilation
			 * because the IF statement can also be a
			 * terminal symbol, i.e. it may be all that
			 * is parsed in one call to the parser.
			 * The parser must look ahead one token
			 * to find if there is an else statement
			 * following.  If there is no following
			 * token an EOF may be detected prematurely.
			 * When the IF statement is being parsed not
			 * inside any braces, then when the next token
			 * is not an ELSE care must be taken that this
			 * token is seen on a subsequent invocation
			 * of the parser.  The `ifseen' flag is
			 * used within the support for the lexical
			 * analyzer located in `history.c'.
			 */
			if (cldebug) 
			    eprintf ("ytab: setting ifseen=yes\n");

			if (currentask->t_flags & T_INTERACTIVE)
			    ifseen = ip_cmdblk;
			else
			    ifseen = cmdblk;
		}
break;
case 210:
#line 1456 "grammar.y"
{
		    int  biffaddr;

		    ifseen = NULL;
		    if (!errcnt) {
			/* Pop and save BIFF address, compile and push addr 
			 * of GOTO, and set BIFF branch to just after GOTO.
			 */
			biffaddr = pop();
			push (compile (GOTO, 0));
			coderef (biffaddr)->c_args = pc - biffaddr - SZ_CE;
		    }
		}
break;
case 211:
#line 1468 "grammar.y"
{
		    int  gotoaddr;
		    if (!errcnt) {
			/* Pop GOTO addr and set branch to just after statement
			 */
			gotoaddr = pop();
			coderef (gotoaddr)->c_args = pc - gotoaddr - SZ_CE;
		    }
		}
break;
case 212:
#line 1479 "grammar.y"
{
		    /* Save starting addr of while expression.
		     */
		    if (!errcnt) {
			push (pc);
			loopincr();
		    }
		}
break;
case 213:
#line 1486 "grammar.y"
{
		    /* Save BIFF addr so branch can be filled in.
		     */
		    if (!errcnt)
			push (compile (BIFF, 0));
		}
break;
case 214:
#line 1491 "grammar.y"
{
		    int  biffaddr;

		    if (!errcnt) {
			/* Pop and save addr of BIFF instruction.	   */
			biffaddr = pop();
			/* Pop addr of expression and build a goto there.  */
			compile (GOTO, pop() - pc - SZ_CE);
			/* Now can set BIFF branch to just after statement.*/
			coderef (biffaddr)->c_args = pc - biffaddr - SZ_CE;
			loopdecr();
		    }
		}
break;
case 215:
#line 1524 "grammar.y"
{
			if (!errcnt)
			    push(pc);				/* Loop1: */
		}
break;
case 216:
#line 1528 "grammar.y"
{
			if (!errcnt) {
			    if (for_expr)
				ppush (compile(BIFF, 0));	/* if (!e2) */

			    /* Add SZ_CE to skip following GOTO. 
			     */
			    ppush (pc+SZ_CE);			/* Loop2: */
			    ppush (compile(GOTO,0));		/* goto Loop3 */

			    /* Save current location as the destination
			     * for NEXT statements.
			     */
			    loopincr();
			}
		}
break;
case 217:
#line 1544 "grammar.y"
{
			int  stmtaddr;

			if (!errcnt) {
			    stmtaddr = pop();
			    compile (GOTO, stmtaddr-pc-SZ_CE); 	/* Goto loop1 */
			    stmtaddr = pop();
			    coderef(stmtaddr)->c_args = pc - stmtaddr - SZ_CE;
			}
		}
break;
case 218:
#line 1554 "grammar.y"
{
			int  stmtaddr;

			if (!errcnt) {
			    stmtaddr = pop();
			    compile (GOTO, stmtaddr-pc-SZ_CE); /* goto loop2 */

			    if (for_expr) {
				stmtaddr = pop();
				coderef(stmtaddr)->c_args = pc-stmtaddr-SZ_CE;
			    }
			    loopdecr();
			}
		}
break;
case 221:
#line 1577 "grammar.y"
{
			for_expr = YES;
		}
break;
case 222:
#line 1580 "grammar.y"
{
			for_expr = NO;
		}
break;
case 223:
#line 1606 "grammar.y"
{
			if (!errcnt) {
			    push (compile(SWITCH));

			    /* Compile GOTO which will branch past end of
			     * switch.  This is needed if there is no DEFAULT.
			     */
			    compile (GOTO, 0);
			}
		}
break;
case 224:
#line 1615 "grammar.y"
{
			/* Set up jumptable and pop space on stack.
			 */
			if (!errcnt)
			    setswitch();
		}
break;
case 225:
#line 1623 "grammar.y"
{
			if (!errcnt) {
			    ncaseval = 0;
			    if (!in_switch()) {
				errmsg = "Improper CASE statement.";
				EYYERROR;
			    }
			}
		}
break;
case 226:
#line 1631 "grammar.y"
{
			int  pcase;

			if (!errcnt) {
			    pcase = compile (CASE, ncaseval);

			    /* Fill in argument list. 
			     */
			    caseset (&(coderef(pcase)->c_args), ncaseval);
			    push (pcase);
			}
		}
break;
case 227:
#line 1642 "grammar.y"
{
			/* Branch to end of switch block 
			 */
			if (!errcnt)
			    push (compile(GOTO, 0));
		}
break;
case 228:
#line 1650 "grammar.y"
{
		      	/* Compile an operand to store the current PC.
			 */
			if (!errcnt) {
			    if (!in_switch()) {
				errmsg = "Improper DEFAULT statement.";
				EYYERROR;
			    }
			    push (compile(DEFAULT));
			}
		}
break;
case 229:
#line 1660 "grammar.y"
{
		      	/* Branch past jump table. 
			 */
			if (!errcnt)
			    push (compile(GOTO, 0));
		}
break;
case 230:
#line 1668 "grammar.y"
{
			/* All NEXT statements are backward references,
			 * so we simply store the addresses in an array.
			 */
			if (!errcnt) {
			    if (nestlevel)
				compile (GOTO, nextdest[nestlevel-1]-pc-SZ_CE);
			    else {
				errmsg = "NEXT outside of loop.";
				EYYERROR;
			    }
			}
		}
break;
case 231:
#line 1683 "grammar.y"
{
			/* Each BREAK is a forward reference.  For the
			 * first BREAK in each loop we compile a
			 * GOTO statement which will be the object of
			 * all BREAK statements within the loop.  When
			 * the loop is terminated the target of this
			 * GOTO will be set.
			 */
			int  dest;

			if (!errcnt) {
			    if (!nestlevel) {
				errmsg = "Break outside of loop.";
				EYYERROR;
			    } else if ((dest = brkdest[nestlevel-1]) != 0)
		    		compile (GOTO, dest-pc-SZ_CE);
			    else {
				brkdest[nestlevel-1] = pc;
				compile (GOTO, 0);
			    }
			}
		}
break;
case 232:
#line 1707 "grammar.y"
{
			if (!errcnt)
			    compile (END);
		}
break;
case 233:
#line 1711 "grammar.y"
{
			/* Return values currently not implemented.
			 */
			eprintf ("Warning: return value ignored.\n");
			if (!errcnt)
			    compile (END);
		}
break;
case 234:
#line 1723 "grammar.y"
{
			bracelevel -= PBRACE;
			if (bracelevel < 0) {
			    errmsg = "Too few left braces.";
			    EYYERROR;
			} else if (bracelevel > 0) {
			    errmsg = "Too few right braces.";
			    EYYERROR;
			}
		}
break;
case 235:
#line 1735 "grammar.y"
{
			/* Put symbol in table in dictionary and
			 * process indirect references if present.
			 */
			struct label *l;

			if (!errcnt) {
			    l = getlabel (stkop(yyvsp[-2]));

			    if (l == NULL) {
				l = setlabel (stkop(yyvsp[-2]));
				l->l_loc = pc;
			    } else if (l->l_defined) {
			        errmsg = "Identical labels.";
				EYYERROR;
			    } else {
				/* Get this GOTO out of the
				 * indirect list so we can use
				 * the argument as the destination
				 */
				int  gotopc;
				gotopc = l->l_loc;
				unsetigoto (gotopc);

				/* Fix the indirect reference. 
				 */
				coderef(gotopc)->c_args = pc - gotopc - SZ_CE;
			    }
			    (l->l_defined)++;
			}
		}
break;
case 237:
#line 1769 "grammar.y"
{
			/* Get the address corresponding to the label.
			 */
			struct label *l;

			if (!errcnt) {
			    l = getlabel (stkop(yyvsp[0]));

			    if (l != NULL)
				compile (GOTO, l->l_loc - pc - SZ_CE);
			    else {
				/* Ready for indirect GOTO 
				 */
				l = setlabel (stkop(yyvsp[0]));
				l->l_loc = pc;
				setigoto (compile(GOTO, 0));
				l->l_defined = 0;
			    }
			}
		}
break;
case 240:
#line 1799 "grammar.y"
{ 
			/* Save pc before compiling statement for loop back
			 */
			stmt_pc = pc;
			n_oarr = 0;
			i_oarr = 0;
			ifseen = NULL;
		}
break;
case 241:
#line 1807 "grammar.y"
{
		      	/* If there was an open reference compile the
			 * loop increment and goback.
			 */
			int push_pc;

			if (!errcnt) {
			    if (n_oarr) {
				compile (INDXINCR, stmt_pc-pc-4, 2*n_oarr+1);

				/* We are going to store initialization
				 * info for the implicit loop here.
				 * It is loopincr's responsibility to 
				 * branch around it.  This data is what
				 * should be pointed to by the special
				 * PUSHINDEX compiled at the first open
				 * array reference.
				 */
				push_pc = pop();  /* Location of PUSHINDEX */
				coderef(push_pc)->c_args = pc - push_pc - SZ_CE;

				stack[pc++] = n_oarr;
				for (i_oarr=0; i_oarr<n_oarr; i_oarr++) {
				    stack[pc++] = oarr_beg[i_oarr];
				    stack[pc++] = oarr_end[i_oarr];
				}

				/* Clear n_oarr.  This must be done here
				 * because we may have the end of a compound
				 * statement following on the heels of the
				 * end of the simple statement with the
				 * implicit loop.
				 */
				n_oarr = 0;
				i_oarr = 0;
			    }
			}
		}
break;
case 243:
#line 1846 "grammar.y"
{
		    /* This should get most errors in executable statements
		     * or in the local variable declarations in a script.
		     */
		    yyerrok;

		    /* Get rid of any fake braces.
		     */
		    bracelevel -= tbrace;

		    /* Discard everything and compile a null statement.
		     */
		    if (!errcnt) {
			do_params = YES;
			pc = currentask->t_bascode;
			if (parse_state != PARSE_PARAMS)
			    compile (END);

			topd = currentask->t_topd;
			topcs = currentask->t_topcs;

			/* Unlink any added parms.  Resetting of topd will
			 * already have reclaimed space.
			 */
			if (last_parm) {
			    last_parm->p_np = NULL;
			    currentask->t_pfp->pf_lastpp = last_parm;
			    last_parm = NULL;
			}
 		    }

		    /* Tell user about the syntax error, printing the 
		     * offending line and position if possible.
		     */
		    if (currentask->t_flags & T_SCRIPT) {
		        if (errmsg != NULL) {
			    eprintf ("** Syntax error, line %d: %s\n",
			        currentask->t_scriptln, errmsg);
			} else {
			    eprintf ("** Syntax error, line %d\n",
			        currentask->t_scriptln);
			}
		    } else
			eprintf ("** Syntax error\n");
		    p_position();

		    if (!(currentask->t_flags & T_SCRIPT)) {
			/* If interactive, we're finished if not within braces.
			 */
			if (!bracelevel)
			    YYACCEPT;
		    }

		    /* Note that we do not call cl_error() here to abort, but
		     * continue on parsing the script for more syntax errors.
		     */
		    if (++errcnt > MAX_ERR)
			cl_error (E_UERR, "Too many syntax errors.");
		}
break;
case 246:
#line 1911 "grammar.y"
{
				if (!errcnt) {
				    push(stkop(yyvsp[0])) ; 
				    ncaseval++;
				}
			}
break;
case 249:
#line 1931 "grammar.y"
{
			int  dim, d, i1, i2, mode;

			/*  In command arguments, when not in parentheses
			 *  we just pass the param as a string constant.
			 */
			if (!errcnt) {
			    lastref = NO;
			    if (!inarglist || parenlevel) {
				i_oarr = 0;
				index_cnt = 0;

				strncpy (curr_param, stkop(yyvsp[0])->o_val.v_s, 
					SZ_FNAME);

				/* If a '.' is found in the name we have a 
				 * reference to an external task, or to a 
				 * specific field.  In these cases we don't 
				 * want implicit looping.
				 */
				if (index (curr_param, '.') == NULL) {
				    if ((dim = get_dim (curr_param)) > 0) {
					lastref = YES;
			        	for (d = 0; d < dim; d++) {
					    getlimits (curr_param, d, &i1, &i2);
					    mode = make_imloop (i1, i2);
					    if (mode)
						compile (PUSHINDEX, -1);
					    else
						push (compile(PUSHINDEX, 0));	
					}
			    		n_oarr = dim;
				    }
				}
			    }
			}
		}
break;
case 250:
#line 1968 "grammar.y"
{
		    if (!errcnt) {
			strncpy (curr_param, stkop(yyvsp[0])->o_val.v_s, SZ_FNAME);
			index_cnt = 0;
		    }
		}
break;
case 251:
#line 1975 "grammar.y"
{
		    if (i_oarr > 0  &&  n_oarr == 0)
			n_oarr = i_oarr;
		    i_oarr = 0;
		    lastref = YES;
		}
break;
case 252:
#line 1983 "grammar.y"
{
			index_cnt = 1;
		}
break;
case 253:
#line 1986 "grammar.y"
{
			index_cnt++;
		}
break;
case 255:
#line 1992 "grammar.y"
{
			if (!errcnt)
			    compile (PUSHINDEX, 0);
		}
break;
case 256:
#line 1997 "grammar.y"
{ 
			if (!errcnt) {
			    compile (PUSHPARAM, stkop(yyvsp[0])->o_val.v_s);
			    compile (PUSHINDEX, 0);
			}
		}
break;
case 257:
#line 2003 "grammar.y"
{
			int  i1, i2, mode;

			if (!errcnt) {
			    if (index(curr_param, '.') != NULL) {
				errmsg = exlimits;
				EYYERROR;
			    }
			    if (getlimits (curr_param, index_cnt, &i1, &i2) 
				== ERR) {
				eprintf ("Implicit index error for %s.\n",
					curr_param);
				EYYERROR;
			    }
			    mode = make_imloop (i1, i2);
			    if (mode)
				compile (PUSHINDEX, mode);
			    else
				push (compile (PUSHINDEX, mode));
			}
		}
break;
case 258:
#line 2024 "grammar.y"
{
			/*  There is an ambiguity in the grammar between
			 *  sexagesimal constants, and array range references.
			 *  Since the sexagesimal constants are recognized
			 *  in the lexical analyzer we can't just change the
			 *  grammar.  The kludge around this is to have
			 *  makeop set a flag telling us that the last
			 *  constant it compiled COULD have been an index
			 *  range.  We check the flag here and if it is
			 *  set we convert back and compile an implicit loop
			 *  otherwise we just push the constant.
			 */
			int  i1, i2, mode;

			if (!errcnt) {
			    if (maybeindex) {
				sexa_to_index (stkop(yyvsp[0])->o_val.v_r, &i1, &i2);
				mode = make_imloop (i1, i2);
				if (mode)
				    compile (PUSHINDEX, mode);
				else
				    push (compile (PUSHINDEX, mode));
			    } else {
				compile (PUSHCONST, stkop(yyvsp[0]));
				compile (PUSHINDEX, 0);
			    }
			}
		}
break;
case 259:
#line 2058 "grammar.y"
{
		    yyval = yyvsp[0];
		}
break;
case 260:
#line 2063 "grammar.y"
{
		    yyval = yyvsp[0];
		}
break;
case 261:
#line 2068 "grammar.y"
{
		    yyval = yyvsp[0];
		}
break;
case 263:
#line 2074 "grammar.y"
{
		    /* If statements are delimited by ';'s, do not execute
		     * until next newline EOST is received.
		     */
		    sawnl = 0;
		}
break;
case 269:
#line 2096 "grammar.y"
{ parenlevel++; }
break;
case 270:
#line 2099 "grammar.y"
{ --parenlevel; }
break;
case 271:
#line 2102 "grammar.y"
{ sawnl = 1; }
break;
#line 3621 "y.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yysslim && yygrowstack())
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
