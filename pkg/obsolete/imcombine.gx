# Copyright(c) 1986 Association of Universities for Research in Astronomy Inc.

include	<imhdr.h>
include	<imset.h>
include	<error.h>
include	<syserr.h>

define	SUM		1	# Sum of the images
define	AVERAGE		2	# Average of the images
define	MEDIAN		3	# Median of the images
define	MINREJECT	4	# Reject minimum
define	MAXREJECT	5	# Reject maximin
define	MINMAXREJECT	6	# Reject minimum and maximum
# 	newline		7
define	THRESHOLD	8	# Absolute threshold clip
define	SIGCLIP		9	# Sigma clip using sigma at each point
define	AVSIGCLIP	10	# Sigma clip using average sigma

# IMCOMBINE -- Combine images
#
# The memory and open file descriptor limits are checked and an attempt
# to recover is made either by setting the image pixel files to be
# closed after I/O or by notifying the calling program that memory
# ran out and the IMIO buffer size should be reduced.  After the checks
# a procedure for the selected combine option is called.
# Because there may be several failure modes when reaching the file
# limits we first assume an error is due to the file limit, except for
# out of memory, and close some pixel files.  If the error then repeats
# on accessing the pixels the error is passed back.

$for (silrdx)
procedure imcombine$t (log, in, nimages, out, sig, bufsize, option)

int	log			# Log file descriptor
pointer	in[nimages]		# Input IMIO pointers
int	nimages			# Number of input images
pointer	out			# Output IMIO pointer
pointer	sig			# Sigma IMIO pointer
int	bufsize			# IMIO buffer size
int	option			# Combine option

char	str[1]
int	i, j, fd, stropen(), errcode(), imstati()
pointer	data, imgl1$t()
$if (datatype == sil)
pointer	impl1r()
$else
pointer	impl1$t()
$endif

begin
	# Reserve FD for string operations.
	fd = stropen (str, 1, NEW_FILE)

	# Do I/O to the output images.
	i = IM_LEN(out, 1)
	call imseti (out, IM_BUFSIZE, bufsize)
	$if (datatype == sil)
	data = impl1r (out)
	call aclrr (Memr[data], i)
	if (sig != NULL) {
	    data = impl1r (sig)
	    call aclrr (Memr[data], i)
	}
	$else
	data = impl1$t (out)
	call aclr$t (Mem$t[data], i)
	if (sig != NULL) {
	    data = impl1$t (sig)
	    call aclr$t (Mem$t[data], i)
	}
	$endif

	# Do I/O from the input images.
	do i = 1, nimages {
	    call imseti (in[i], IM_BUFSIZE, bufsize)
	    iferr (data = imgl1$t (in[i])) {
		switch (errcode()) {
	        case SYS_MFULL:
		    call strclose (fd)
		    call erract (EA_ERROR)
		default:
		    if (imstati (in[i], IM_CLOSEFD) == YES) {
			call strclose (fd)
		        call error (1, "imcombine - Too many images to combine")
		    }
		    do j = i-2, nimages
		        call imseti (in[j], IM_CLOSEFD, YES)
	            data = imgl1$t (in[i])
		}
	    }
	}

	call strclose (fd)

	switch (option) {
	case SUM:
	    call imc_sum$t (log, in, out, nimages)
	case AVERAGE:
	    call imc_average$t (log, in, out, sig, nimages)
	case MEDIAN:
	    call imc_median$t (log, in, out, sig, nimages)
	$if (datatype == silrd)
	case SIGCLIP:
	    call imc_sigclip$t (log, in, out, sig, nimages)
	case AVSIGCLIP:
	    call imc_asigclip$t (log, in, out, sig, nimages)
	$endif
	case THRESHOLD:
	    call imc_threshold$t (log, in, out, sig, nimages)
	case MINREJECT:
	    call imc_minrej$t (log, in, out, sig, nimages)
	case MAXREJECT:
	    call imc_maxrej$t (log, in, out, sig, nimages)
	case MINMAXREJECT:
	    call imc_mmrej$t (log, in, out, sig, nimages)
	}
end
$endfor
