# Copyright(c) 1986 Association of Universities for Research in Astronomy Inc.

include	<imhdr.h>

.help imcthreshold
.nf ----------------------------------------------------------------------------
          COMBINING IMAGES: THRESHOLD REJECTION ALGORITHM

The input images are combined by scaling and taking a weighted
average.  Pixels having values below and above a rejection threshold
(before scaling) are excluded from the average.  The exposure time of
the output image is the scaled and weighted average of the input
exposure times.  The average is computed in real arithmetic with
trunction on output if the output image is an integer datatype.

PROCEDURES:

    IMC_THRESHOLD -- Combine the images by averaging with threshold rejection.
    THRESHOLD -- Average and reject the lines (scales and weights equal).
    WTTHRESHOLD -- Average and reject the lines (scales and weights unequal).
.endhelp -----------------------------------------------------------------------

$for (silrdx)
# IMC_THRESHOLD -- Combine the input images by averaging with threshold
# rejection.  Each input image, given by an array of image pointers, is
# scaled and then a weighted average is computed rejecting values which are
# outside the lower and upper threshold.  The output image header
# is updated to include a scaled and weighted exposure time and the number
# of images combined.

procedure imc_threshold$t (log, in, out, sig, nimages)

int	log			# Log file descriptor
pointer	in[nimages]		# Input images
pointer	out			# Output image
pointer	sig			# Sigma image
int	nimages			# Number of input images

int	i, j, nc
pointer	sp, data, scales, zeros, wts, outdata, sigdata, v1, v2
bool	scale, imc_scales()
real	low, high, blank, clgetr()
pointer	imgnl$t()
$if (datatype == sil)
pointer	impnlr()
$else
pointer	impnl$t()
$endif

begin
	call smark (sp)
	call salloc (data, nimages, TY_INT)
	call salloc (scales, nimages, TY_REAL)
	call salloc (zeros, nimages, TY_REAL)
	call salloc (wts, nimages, TY_REAL)
	call salloc (v1, IM_MAXDIM, TY_LONG)
	call salloc (v2, IM_MAXDIM, TY_LONG)
	call amovkl (long(1), Meml[v1], IM_MAXDIM)
	call amovkl (long(1), Meml[v2], IM_MAXDIM)

	# Get the rejection thresholds and scaling factors and weights.
	low = clgetr ("lowreject")
	high = clgetr ("highreject")
	blank = clgetr ("blank")
	if (low >= high)
	    call error (0, "Bad threshold limits (lowreject >= highreject)")
	scale = imc_scales ("threshold", log, low, high, in, out, Memr[scales],
	    Memr[zeros], Memr[wts], nimages)

	# For each line get input and ouput image lines and call a procedure
	# to perform the averging on the line.

	nc = IM_LEN(out,1)
	$if (datatype == sil)
	if (scale) {
	    while (impnlr (out, outdata, Meml[v1]) != EOF) {
		do i = 1, nimages {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = imgnl$t (in[i], Memi[data+i-1], Meml[v1])
		}
		call wtthreshold$t (Memi[data], Memr[scales], Memr[zeros],
		    Memr[wts], nimages, Memr[outdata], nc, low, high, blank)
		if (sig != NULL) {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = impnlr (sig, sigdata, Meml[v1])
		    call wtsigma$t (Memi[data], Memr[scales], Memr[zeros],
			Memr[wts], nimages, Memr[outdata], Memr[sigdata], nc)
		}
		call amovl (Meml[v1], Meml[v2], IM_MAXDIM)
	    }
	} else {
	    while (impnlr (out, outdata, Meml[v1]) != EOF) {
		do i = 1, nimages {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = imgnl$t (in[i], Memi[data+i-1], Meml[v1])
		}
		call threshold$t (Memi[data], nimages, Memr[outdata], nc,
		    low, high, blank)
		if (sig != NULL) {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = impnlr (sig, sigdata, Meml[v1])
		    call sigma$t (Memi[data], nimages, Memr[outdata],
			Memr[sigdata], nc)
		}
		call amovl (Meml[v1], Meml[v2], IM_MAXDIM)
	    }
	}
	$else
	if (scale) {
	    while (impnl$t (out, outdata, Meml[v1]) != EOF) {
		do i = 1, nimages {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = imgnl$t (in[i], Memi[data+i-1], Meml[v1])
		}
		call wtthreshold$t (Memi[data], Memr[scales], Memr[zeros],
		    Memr[wts], nimages, Mem$t[outdata], nc, low, high, blank)
		if (sig != NULL) {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = impnl$t (sig, sigdata, Meml[v1])
		    call wtsigma$t (Memi[data], Memr[scales], Memr[zeros],
			Memr[wts], nimages, Mem$t[outdata], Mem$t[sigdata], nc)
		}
		call amovl (Meml[v1], Meml[v2], IM_MAXDIM)
	    }
	} else {
	    while (impnl$t (out, outdata, Meml[v1]) != EOF) {
		do i = 1, nimages {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = imgnl$t (in[i], Memi[data+i-1], Meml[v1])
		}
		call threshold$t (Memi[data], nimages, Mem$t[outdata], nc,
		    low, high, blank)
		if (sig != NULL) {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = impnl$t (sig, sigdata, Meml[v1])
		    call sigma$t (Memi[data], nimages, Mem$t[outdata],
			Mem$t[sigdata], nc)
		}
		call amovl (Meml[v1], Meml[v2], IM_MAXDIM)
	    }
	}
	$endif

	call sfree (sp)
end


# THRESHOLD -- Compute the average image line with threshold rejection.
# The input data is type dependent and the output is real.

procedure threshold$t (data, nimages, average, npts, low, high, blank)

pointer	data[nimages]		# Data pointers
int	nimages			# Number of images
$if (datatype == sil)
real	average[npts]		# Average line (returned)
real	sum, val
$else
PIXEL	average[npts]		# Average line (returned)
PIXEL	sum, val
$endif
int	npts			# Number of data points
real	low			# Low rejection threshold
real	high			# Low rejection threshold
real	blank			# Blank value if all points rejected

int	i, j, nsum
$if (datatype == x)
real	absval
$endif

begin
	do i = 1, npts {
	    sum = 0.
	    nsum = 0
	    do j = 1, nimages {
		val = Mem$t[data[j]+i-1]
	        $if (datatype == x)
		absval = abs (val)
		if ((absval < low) || (absval > high))
	        $else
		if ((val < low) || (val > high))
		$endif
		    Mem$t[data[j]+i-1] = INDEF
		else {
		   sum = sum + val
		   nsum = nsum + 1
		}
	    }
	    if (nsum > 0)
		average[i] = sum / nsum
	    else
		average[i] = blank
	}
end


# WTTHRESHOLD -- Compute the weighted average image line with threshold
# rejection.  The input data is type dependent and the output is real.

procedure wtthreshold$t (data, scales, zeros, wts, nimages, average, npts,
	low, high, blank)

pointer	data[nimages]		# IMIO data pointers
real	scales[nimages]		# Scale factors
real	zeros[nimages]		# Zero levels
real	wts[nimages]		# Weights
int	nimages			# Number of data lines
$if (datatype == sil)
real	average[npts]		# Average line (returned)
real	sum, val
$else
PIXEL	average[npts]		# Average line (returned)
PIXEL	sum, val
$endif
int	npts			# Number of data points per line
real	low			# Low rejection threshold
real	high			# Low rejection threshold
real	blank			# Blank value if all points rejected

int	i, j
real	nsum
$if (datatype == x)
real	absval
$endif

begin
	do i = 1, npts {
	    sum = 0.
	    nsum = 0.
	    do j = 1, nimages {
		val = Mem$t[data[j]+i-1]
	        $if (datatype == x)
		absval = abs (val)
		if ((absval < low) || (absval > high))
	        $else
		if ((val < low) || (val > high))
		$endif
		    Mem$t[data[j]+i-1] = INDEF
		else {
		    sum = sum + wts[j] * (val / scales[j] - zeros[j])
		    nsum = nsum + wts[j]
		}
	    }
	    if (nsum > 0)
		average[i] = sum / nsum
	    else
		average[i] = blank
	}
end
$endfor
