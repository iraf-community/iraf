# Copyright(c) 1986 Association of Universities for Research in Astronomy Inc.

include	<imhdr.h>

.help imcmedian
.nf ----------------------------------------------------------------------------
              COMBINING IMAGES: MEDIAN ALGORITHM

The input images are combined by scaling and taking the median.
The exposure time of the output image is the scaled and weighted
average of the input exposure times.  If some of the input images are
real datatypes and the output image is short datatype there may be
some truncation.

PROCEDURES:

    IMC_MEDIAN -- Combine the images by scaling and taking the median.
    MEDIAN -- Median of lines (no scaling).
    SCMEDIAN -- Scaled median of lines.
.endhelp -----------------------------------------------------------------------

$for (silrdx)
# IMC_MEDIAN -- Combine the images by scaling and taking the median.
# Each input image, given by an array of image pointers, is
# scaled and then a median is computed.  The output image header
# is updated to include a scaled and weighted exposure time and the number
# of images combined.

procedure imc_median$t (log, in, out, sig, nimages)

int	log			# Log file descriptor
pointer	in[nimages]		# Input images
pointer	out			# Output images
pointer	sig			# Sigma image
int	nimages			# Number of input images

int	i, j, nc
pointer	sp, data, scales, zeros, wts, outdata, sigdata, v1, v2
bool	scale, imc_scales()
pointer	imgnl$t()
$if (datatype == sil)
pointer	impnlr()
$else
pointer	impnl$t()
$endif

begin
	if (nimages == 1) {
	    call imc_copy$t (in[1], out)
	    return
	}

	call smark (sp)
	call salloc (data, nimages, TY_REAL)
	call salloc (scales, nimages, TY_REAL)
	call salloc (zeros, nimages, TY_REAL)
	call salloc (wts, nimages, TY_REAL)
	call salloc (v1, IM_MAXDIM, TY_LONG)
	call salloc (v2, IM_MAXDIM, TY_LONG)
	call amovkl (long(1), Meml[v1], IM_MAXDIM)
	call amovkl (long(1), Meml[v2], IM_MAXDIM)

	# Get the scaling factors and weights.
	scale = imc_scales ("median", log, 0., 0., in, out, Memr[scales],
	    Memr[zeros], Memr[wts], nimages)

	# For each line get input and ouput image lines and call a procedure
	# to perform the median on the line.

	nc = IM_LEN(out,1)
	$if (datatype == sil)
	if (scale) {
	    while (impnlr (out, outdata, Meml[v1]) != EOF) {
		do i = 1, nimages {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = imgnl$t (in[i], Memi[data+i-1], Meml[v1])
		}
		call scmedian$t (Memi[data], Memr[scales], Memr[zeros], nimages,
		    Memr[outdata], nc)
		if (sig != NULL) {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = impnlr (sig, sigdata, Meml[v1])
		    call wtsigma$t (Memi[data], Memr[scales], Memr[zeros],
			Memr[wts], nimages, Memr[outdata], Memr[sigdata], nc)
		}
		call amovl (Meml[v1], Meml[v2], IM_MAXDIM)
	    }
	} else {
	    while (impnlr (out, outdata, Meml[v1]) != EOF) {
		do i = 1, nimages {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = imgnl$t (in[i], Memi[data+i-1], Meml[v1])
		}
		call median$t (Memi[data], nimages, Memr[outdata], nc)
		if (sig != NULL) {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = impnlr (sig, sigdata, Meml[v1])
		    call sigma$t (Memi[data], nimages, Memr[outdata],
			Memr[sigdata], nc)
		}
		call amovl (Meml[v1], Meml[v2], IM_MAXDIM)
	    }
	}
	$else
	if (scale) {
	    while (impnl$t (out, outdata, Meml[v1]) != EOF) {
		do i = 1, nimages {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = imgnl$t (in[i], Memi[data+i-1], Meml[v1])
		}
		call scmedian$t (Memi[data], Memr[scales], Memr[zeros], nimages,
		    Mem$t[outdata], nc)
		if (sig != NULL) {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = impnl$t (sig, sigdata, Meml[v1])
		    call wtsigma$t (Memi[data], Memr[scales], Memr[zeros],
			Memr[wts], nimages, Mem$t[outdata], Mem$t[sigdata], nc)
		}
		call amovl (Meml[v1], Meml[v2], IM_MAXDIM)
	    }
	} else {
	    while (impnl$t (out, outdata, Meml[v1]) != EOF) {
		do i = 1, nimages {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = imgnl$t (in[i], Memi[data+i-1], Meml[v1])
		}
		call median$t (Memi[data], nimages, Mem$t[outdata], nc)
		if (sig != NULL) {
		    call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
		    j = impnl$t (sig, sigdata, Meml[v1])
		    call sigma$t (Memi[data], nimages, Mem$t[outdata],
			Mem$t[sigdata], nc)
		}
		call amovl (Meml[v1], Meml[v2], IM_MAXDIM)
	    }
	}
	$endif

	call sfree (sp)
end


# SCMEDIAN -- Median of lines with scaling.

procedure scmedian$t (data, scales, zeros, nimages, median, npts)

pointer	data[nimages]		# Input data line pointers
real	scales[nimages]		# Image scale factors
real	zeros[nimages]		# Image zero levels
int	nimages			# Number of images
$if (datatype == sil)
real	median[npts]		# Output data line
$else
PIXEL	median[npts]		# Output data line
$endif
int	npts			# Number of output points

int	i, j
real	s, z
pointer	sp, ptr1
$if (datatype == sil)
pointer	work[7], ptr2
$endif

begin
	call smark (sp)
	$if (datatype == sil)
	if (nimages < 8) {
	    do i = 1, nimages {
	        call salloc (work[i], npts, TY_REAL)
		ptr1 = data[i]
		ptr2 = work[i]
		s = scales[i]
		z = zeros[i]
		do j = 1, npts {
		    Memr[ptr2] = Mem$t[ptr1] / s - z
		    ptr1 = ptr1 + 1
		    ptr2 = ptr2 + 1
		}
	    }
	    call imc_amedr (work, nimages, median, npts)
	} else {
	    call salloc (ptr1, nimages, TY_REAL)
	    call imc_ssok$t (data, scales, zeros, Memr[ptr1], nimages,
	        median, npts)
	}
	$else
	if (nimages < 8) {
	    do i = 1, nimages {
		ptr1 = data[i]
		s = scales[i]
		z = zeros[i]
		do j = 1, npts {
		    Mem$t[ptr1] = Mem$t[ptr1] / s - z
		    ptr1 = ptr1 + 1
		}
	    }
	    call imc_amed$t (data, nimages, median, npts)
	} else {
	    call salloc (ptr1, nimages, TY_PIXEL)
	    call imc_ssok$t (data, scales, zeros, Mem$t[ptr1], nimages,
		median, npts)
	}
	$endif
	call sfree (sp)
end


# MEDIAN -- Median of lines with no scaling.

procedure median$t (data, nimages, median, npts)

pointer	data[nimages]		# Input data line pointers
int	nimages			# Number of images
$if (datatype == sil)
real	median[npts]		# Output data line
$else
PIXEL	median[npts]		# Output data line
$endif
int	npts			# Number of output points

pointer	sp, work

begin
	if (nimages < 8)
	    call imc_amed$t (data, nimages, median, npts)
	else {
	    call smark (sp)
	    call salloc (work, nimages, TY_PIXEL)
	    call imc_sok$t (data, Mem$t[work], nimages, median, npts)
	    call sfree (sp)
	}
end

# IMC_SOK -- Select median with no scaling.
# 
# This is a modifications of the VOPS ASOK procedure.  The algorithm used
# is selection by tail recursion (Gonnet 1984).  In each iteration a pivot key
# is selected (somewhat arbitrarily) from the array.  The array is then split
# into two subarrays, those with key values less than or equal to the pivot key
# and those with values greater than the pivot.  The size of the two subarrays
# determines which contains the median value, and the process is repeated
# on that subarray, and so on until all of the elements of the subarray
# are equal, e.g., there is only one element left in the subarray.  For a
# randomly ordered array the expected running time is O(3.38N).  The selection
# is carried out in place, leaving the array in a partially ordered state.
#
# N.B.: Behaviour is O(N) if the input array is sorted.
# N.B.: The cases ksel=1 and ksel=npix, i.e., selection of the minimum and
# maximum values, are more efficiently handled by ALIM which is O(2N).

procedure imc_sok$t (data, a, npix, median, npts)

pointer	data[npix]		# Data vectors
PIXEL	a[npix]			# work array
int	npix			# number of pixels
$if (datatype == sil)
real	median[npts]		# median vector (returned)
$else
PIXEL	median[npts]		# median vector (returned)
$endif
int	npts			# number of points in vector

int	ksel, lo, up, i, j, k, l
PIXEL	temp
$if (datatype == x)
real	abs_temp
$endif

begin
	ksel = (npix + 1) / 2
	do l = 1, npts {
	    i = l - 1
	    do j = 1, npix
		a[j] = Mem$t[data[j]+i]

	    lo = 1
	    up = npix
	    k  = max (lo, min (up, ksel))

	    while (up >= k && k >= lo) {
	        i = lo
	        j = up
	        temp = a[k];  a[k] = a[lo];  a[lo] = temp
	        $if (datatype == x)
	        abs_temp = abs (temp)
	        $endif

	        # Split array into two.
	        while (i < j) {
		    $if (datatype == x)
		    while (abs (a[j]) > abs_temp)
		    $else
		    while (a[j] > temp)
		    $endif
		        j = j - 1
		    a[i] = a[j]
		    $if (datatype == x)
		    while (i < j && abs (a[i]) <= abs_temp)
		    $else
		    while (i < j && a[i] <= temp)
		    $endif
		        i = i + 1
		    a[j] = a[i]
	        }
	        a[i] = temp

	        # Select the subarray containing the Kth element.
	        if (k < i)
		    up = i - 1
	        else
		    lo = i + 1
	    }

	    median[l] = a[k]
	}
end


# IMC_SSOK -- Scaled median of vectors.
#
# This is a modifications of the VOPS ASOK procedure.  The algorithm used
# is selection by tail recursion (Gonnet 1984).  In each iteration a pivot key
# is selected (somewhat arbitrarily) from the array.  The array is then split
# into two subarrays, those with key values less than or equal to the pivot key
# and those with values greater than the pivot.  The size of the two subarrays
# determines which contains the median value, and the process is repeated
# on that subarray, and so on until all of the elements of the subarray
# are equal, e.g., there is only one element left in the subarray.  For a
# randomly ordered array the expected running time is O(3.38N).  The selection
# is carried out in place, leaving the array in a partially ordered state.
#
# N.B.: Behaviour is O(N) if the input array is sorted.
# N.B.: The cases ksel=1 and ksel=npix, i.e., selection of the minimum and
# maximum values, are more efficiently handled by ALIM which is O(2N).

procedure imc_ssok$t (data, scales, zeros, a, npix, median, npts)

pointer	data[npix]		# Data vectors
real	scales[npix]		# scales
real	zeros[npix]		# zeros
$if (datatype == sil)
real	a[npix]			# work array
real	median[npts]		# median vector (returned)
$else
PIXEL	a[npix]			# work array
PIXEL	median[npts]		# median vector (returned)
$endif
int	npix			# number of pixels
int	npts			# number of points in vector

int	ksel, lo, up, i, j, k, l
$if (datatype == sil)
real	temp
$else
PIXEL	temp
$endif
$if (datatype == x)
real	abs_temp
$endif

begin
	ksel = (npix + 1) / 2
	do l = 1, npts {
	    i = l - 1
	    do j = 1, npix
		a[j] = Mem$t[data[j]+i] / scales[j] - zeros[j]

	    lo = 1
	    up = npix
	    k  = max (lo, min (up, ksel))

	    while (up >= k && k >= lo) {
	        i = lo
	        j = up
	        temp = a[k];  a[k] = a[lo];  a[lo] = temp
	        $if (datatype == x)
	        abs_temp = abs (temp)
	        $endif

	        # Split array into two.
	        while (i < j) {
		    $if (datatype == x)
		    while (abs (a[j]) > abs_temp)
		    $else
		    while (a[j] > temp)
		    $endif
		        j = j - 1
		    a[i] = a[j]
		    $if (datatype == x)
		    while (i < j && abs (a[i]) <= abs_temp)
		    $else
		    while (i < j && a[i] <= temp)
		    $endif
		        i = i + 1
		    a[j] = a[i]
	        }
	        a[i] = temp

	        # Select the subarray containing the Kth element.
	        if (k < i)
		    up = i - 1
	        else
		    lo = i + 1
	    }

	    median[l] = a[k]
	}
end


# IMC_AMED -- Given an array of vector pointers for each element in the vectors
# find the median.  This algorithm is good for small numbers of vectors.
# It is specialized to return median as a real vector if the input is integer.

procedure imc_amed$t (a, nvecs, median, npts)

pointer	a[nvecs]			# Array of vector pointers
int	nvecs				# Number of vectors
$if (datatype == sil)
real	median[npts]			# Median vector
$else
PIXEL	median[npts]			# Median vector
$endif
int	npts				# Number of points in the vectors

int	i, j, nleft
pointer	k, l
$if (datatype == x)
real	val1, val2, val3
$else
PIXEL	val1, val2, val3
$endif

begin
	nleft = nvecs
	while (nleft > 3) {
	    do i = 0, npts - 1 {
	        l = a[1] + i
		$if (datatype == x)
	        val1 = abs (Mem$t[l])
		$else
	        val1 = Mem$t[l]
		$endif
	        do j = 2, nleft {
		    k = a[j] + i
		    $if (datatype == x)
	            val2 = abs (Mem$t[k])
		    $else
		    val2 = Mem$t[k]
		    $endif
	            if (val2 > val1) {
		        l = k
		        val1 = val2
		    }
	        }
	        if (l != k)
	            Mem$t[l] = Mem$t[k]
	    }
	    nleft = nleft - 1
	    if (nleft == 3)
		 break
	    do i = 0, npts - 1 {
	        l = a[1] + i
		$if (datatype == x)
	        val1 = abs (Mem$t[l])
		$else
	        val1 = Mem$t[l]
		$endif
	        do j = 2, nleft {
		    k = a[j] + i
		    $if (datatype == x)
	            val2 = abs (Mem$t[k])
		    $else
		    val2 = Mem$t[k]
		    $endif
	            if (val2 < val1) {
		        l = k
		        val1 = val2
		    }
	        }
	        if (l != k)
	            Mem$t[l] = Mem$t[k]
	    }
	    nleft = nleft - 1
	}

	if (nleft == 3) {
	    do i = 1, npts {
	        j = i - 1
		$if (datatype == x)
	        val1 = abs (Mem$t[a[1]+j])
	        val2 = abs (Mem$t[a[2]+j])
	        val3 = abs (Mem$t[a[3]+j])
	        if (val1 < val2) {
		    if (val2 < val3)		# abc
		        median[i] = Mem$t[a[2]+j]
		    else if (val1 < val3)	# acb
		        median[i] = Mem$t[a[3]+j]
		    else			# cab
		        median[i] = Mem$t[a[1]+j]
	        } else {
		    if (val2 > val3)		# cba
		        median[i] = Mem$t[a[2]+j]
		    else if (val1 > val3)	# bca
		        median[i] = Mem$t[a[3]+j]
		    else			# bac
		        median[i] = Mem$t[a[1]+j]
	        }
		$else
	        val1 = Mem$t[a[1]+j]
	        val2 = Mem$t[a[2]+j]
	        val3 = Mem$t[a[3]+j]
	        if (val1 < val2) {
		    if (val2 < val3)		# abc
		        median[i] = val2
		    else if (val1 < val3)	# acb
		        median[i] = val3
		    else			# cab
		        median[i] = val1
	        } else {
		    if (val2 > val3)		# cba
		        median[i] = val2
		    else if (val1 > val3)	# bca
		        median[i] = val3
		    else			# bac
		        median[i] = val1
	        }
		$endif
	    }
	} else if (nleft == 2) {
	    $if (datatype == x)
	    do i = 1, npts {
		j = i - 1
		val1 = abs (Mem$t[a[1]+j])
		val2 = abs (Mem$t[a[2]+j])
		if (val1 < val2)
		    median[i] = Mem$t[a[1]+j]
		else
		    median[i] = Mem$t[a[2]+j]
	    }
	    $else
	    do i = 1, npts {
		j = i - 1
		val1 = Mem$t[a[1]+j]
		val2 = Mem$t[a[2]+j]
		if (val1 < val2)
		    median[i] = val1
		else
		    median[i] = val2
	    }
	    $endif
	} else {
	    $if (datatype == sil)
	    call acht$tr (Mem$t[a[1]], median, npts)
	    $else
	    call amov$t (Mem$t[a[1]], median, npts)
	    $endif
	}
end
$endfor
