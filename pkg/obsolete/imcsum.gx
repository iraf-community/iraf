# Copyright(c) 1986 Association of Universities for Research in Astronomy Inc.

include	<imhdr.h>

.help imcsum
.nf ----------------------------------------------------------------------------
                COMBINING IMAGES: SUMMING ALGORITHM

The input images are summed.  The exposure time of the output image is the
sum of the input exposure times.  There is no checking for overflow.
.endhelp -----------------------------------------------------------------------


# IMC_SUM -- Sum the input images.

$for (silrdx)
procedure imc_sum$t (log, in, out, nimages)

int	log			# Log file descriptor
pointer	in[nimages]		# Input IMIO pointers
pointer	out			# Output IMIO pointer
int	nimages			# Number of input images

int	i, j, npts
pointer	sp, data, outdata, v1, v2, imgnl$t()
$if (datatype == sil)
pointer	impnlr()
$else
pointer	impnl$t()
$endif

begin
	call imc_logsum ("sum", log, in, out, nimages)

	call smark (sp)
	call salloc (data, nimages, TY_INT)
	call salloc (v1, IM_MAXDIM, TY_LONG)
	call salloc (v2, IM_MAXDIM, TY_LONG)
	call amovkl (long(1), Meml[v1], IM_MAXDIM)
	call amovkl (long(1), Meml[v2], IM_MAXDIM)

	npts = IM_LEN(out,1)
	$if (datatype == sil)
	while (impnlr (out, outdata, Meml[v1]) != EOF) {
	    do i = 1, nimages {
	        call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
	        j = imgnl$t (in[i], Memi[data+i-1], Meml[v1])
	    }
	    call sum$t (Memi[data], nimages, Memr[outdata], npts)
	    call amovl (Meml[v1], Meml[v2], IM_MAXDIM)
	}
	$else
	while (impnl$t (out, outdata, Meml[v1]) != EOF) {
	    do i = 1, nimages {
	        call amovl (Meml[v2], Meml[v1], IM_MAXDIM)
	        j = imgnl$t (in[i], Memi[data+i-1], Meml[v1])
	    }
	    call sum$t (Memi[data], nimages, Mem$t[outdata], npts)
	    call amovl (Meml[v1], Meml[v2], IM_MAXDIM)
	}
	$endif

	call sfree (sp)
end


# SUM -- Compute the summed image line.

procedure sum$t (data, nimages, sum, npts)

pointer	data[nimages]		# Data pointers
int	nimages			# Number of images
$if (datatype == sil)
real	sum[npts]		# Summed line (returned)
$else
PIXEL	sum[npts]		# Summed line (returned)
$endif
int	npts			# Number of data points

int	i, j, nleft
pointer	p1, p2, p3, p4

begin
	$if (datatype == sil)
	call aclrr (sum, npts)
	i = 1
	$else
	call aadd$t (Mem$t[data[1]], Mem$t[data[2]], sum, npts)
	i = 3
	$endif

	nleft = nimages - i + 1
	while (nleft > 3) {
	    p1 = data[i]
	    p2 = data[i+1]
	    p3 = data[i+2]
	    p4 = data[i+3]
	    do j = 1, npts {
	        sum[j] = sum[j] + Mem$t[p1] + Mem$t[p2] + Mem$t[p3] + Mem$t[p4]
	        p1 = p1 + 1
	        p2 = p2 + 1
	        p3 = p3 + 1
	        p4 = p4 + 1
	    }
	    i = i + 4
	    nleft = nleft - 4
	}
	if (nleft == 3) {
	    p1 = data[i]
	    p2 = data[i+1]
	    p3 = data[i+2]
	    do j = 1, npts {
	        sum[j] = sum[j] + Mem$t[p1] + Mem$t[p2] + Mem$t[p3]
		p1 = p1 + 1
		p2 = p2 + 1
		p3 = p3 + 1
	    }
	} else if (nleft == 2) {
	    p1 = data[i]
	    p2 = data[i+1]
	    do j = 1, npts {
	        sum[j] = sum[j] + Mem$t[p1] + Mem$t[p2]
	        p1 = p1 + 1
	        p2 = p2 + 1
	    }
	} else if (nleft == 1) {
	    $if (datatype == sil)
	    p1 = data[i]
	    do j = 1, npts {
	        sum[j] = sum[j] + Mem$t[p1]
	        p1 = p1 + 1
	    }
	    $else
	    call aadd$t (Mem$t[data[i]], sum, sum, npts)
	    $endif
	}
end
$endfor
