include <imhdr.h>

$for (silrdx)

# IMREP -- Replace pixels in an image between lower and upper by value.

procedure imrep$t (im, lower, upper, value, img)

pointer	im				# Image descriptor
real	lower, upper			# Range to be replaced
real	value				# Replacement value
real	img				# Imaginary value for complex

pointer	buf1, buf2
int	npix, junk
PIXEL	floor, ceil, newval
long	v1[IM_MAXDIM], v2[IM_MAXDIM]
int	imgnl$t(), impnl$t()

begin
	# Setup start vector for sequential reads and writes.
	call amovkl (long(1), v1, IM_MAXDIM)
	call amovkl (long(1), v2, IM_MAXDIM)

	npix = IM_LEN(im, 1)
	$if (datatype == x)
	newval = complex (value, img)
	$else
	newval = double (value)
	$endif

	# If both lower and upper are INDEF then replace all pixels by value.
	if (IS_INDEFR (lower) && IS_INDEFR (upper)) {
	    while (impnl$t (im, buf2, v2) != EOF)
	        call amovk$t (newval, Mem$t[buf2], npix)

	# If lower is INDEF then all pixels below upper are replaced by value.
	} else if (IS_INDEFR (lower)) {
	    ceil = double (upper)
	    while (imgnl$t (im, buf1, v1) != EOF) {
		junk = impnl$t (im, buf2, v2)
		call amov$t (Mem$t[buf1], Mem$t[buf2], npix)
		call arle$t (Mem$t[buf2], npix, ceil, newval)
	    }

	# If upper is INDEF then all pixels below upper are replaced by value.
	} else if (IS_INDEFR (upper)) {
	    floor = double (lower)
	    while (imgnl$t (im, buf1, v1) != EOF) {
		junk = impnl$t (im, buf2, v2)
		call amov$t (Mem$t[buf1], Mem$t[buf2], npix)
		call arge$t (Mem$t[buf2], npix, floor, newval)
	    }

	# Replace pixels between lower and upper by value.
	} else {
	    floor = double (lower)
	    ceil = double (upper)
	    while (imgnl$t (im, buf1, v1) != EOF) {
		junk = impnl$t (im, buf2, v2)
		call amov$t (Mem$t[buf1], Mem$t[buf2], npix)
		call arep$t (Mem$t[buf2], npix, floor, ceil, newval)
	    }
	}
end


# AREP -- Replace array values which are between floor and ceil by value.

procedure arep$t (a, npts, floor, ceil, newval)

PIXEL	a[npts]				# Input arrays
int	npts				# Number of points
PIXEL	floor, ceil			# Replacement limits
PIXEL	newval				# Replacement value

int	i
$if (datatype == x)
real	abs_floor
real	abs_ceil
$endif

begin
	$if (datatype == x)
	abs_floor = abs (floor)
	abs_ceil = abs (ceil)
	$endif

	do i = 1, npts {
	    $if (datatype == x)
	    if ((abs (a[i]) >= abs_floor) && (abs (a[i]) <= abs_ceil))
	    $else
	    if ((a[i] >= floor) && (a[i] <= ceil))
	    $endif
		a[i] = newval
	}
end


# ARLE -- If A[i] is less than or equal to FLOOR replace by NEWVAL.

procedure arle$t (a, npts, floor, newval)

PIXEL	a[npts]
int	npts
PIXEL	floor, newval

int	i
$if (datatype == x)
real	abs_floor
$endif

begin
	$if (datatype == x)
	abs_floor = abs (floor)
	$endif

	do i = 1, npts
	    $if (datatype == x)
	    if (abs (a[i]) <= abs_floor)
	    $else
	    if (a[i] <= floor)
	    $endif
		a[i] = newval
end


# ARGE -- If A[i] is greater than or equal to CEIL replace by NEWVAL.

procedure arge$t (a, npts, ceil, newval)

PIXEL	a[npts]
int	npts
PIXEL	ceil, newval

int	i
$if (datatype == x)
real	abs_ceil
$endif

begin
	$if (datatype == x)
	abs_ceil = abs (ceil)
	$endif

	do i = 1, npts
	    $if (datatype == x)
	    if (abs (a[i]) >= abs_ceil)
	    $else
	    if (a[i] >= ceil)
	    $endif
		a[i] = newval
end

$endfor
