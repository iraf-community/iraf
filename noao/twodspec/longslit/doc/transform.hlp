.help transform Sep87 noao.twodspec.longslit
.ih
NAME
transform -- Transform longslit images to user coordinates
.ih
USAGE
transform input output fitnames
.ih
PARAMETERS
.ls input
List of input images to be transformed.
.le
.ls output
List of output images.  The number of output images in the list must
match the number of input images.
.le
.ls fitnames  
Names of the user coordinate maps in the database to be used in the transform.
.le
.ls database = "database"
Database containing the coordinate map to be used in transforming the images.
.le
.ls interptype = "spline3"
Image interpolation type.  The allowed types are "nearest" (nearest neighbor),
"linear" (bilinear), "poly3" (bicubic polynomial), "poly5" (biquintic
polynomial), and "spline3" (bicubic polynomial).
.le
.ls flux = yes
Conserve flux per pixel?  If "no" then each output pixel is simply interpolated
from the input image.  If "yes" the interpolated output pixel value is
multiplied by the Jacobean of the transformation (essentially the ratio of
pixel areas between the output and input images).
.le
.ls x1 = INDEF, y1 = INDEF
User coordinates of the first output column and line.  If INDEF then the
smallest value corresponding to a pixel from the image used to create the
coordinate map is used.  These values are in user units regardless of whether
logarithmic intervals are specified or not.
.le
.ls x2 = INDEF, y2 = INDEF
User coordinates of the last output column and line.  If INDEF then the
largest value corresponding to a pixel from the image used to create the
coordinate map is used.  These values are in user units regardless of whether
logarithmic intervals are specified or not.
.le
.ls dx = INDEF, dy = INDEF
Output pixel intervals.  If INDEF then the interval is set to yield the
specified number of pixels.  Note that for logarithmic intervals the
interval must be specified as a base 10 logarithm (base 10) and not in
user units.
.le
.ls nx = INDEF, ny = INDEF
Number of output pixels.  If INDEF and if the pixel interval is also INDEF then
the number of output pixels is equal to the number of input pixels.
.le
.ls xlog = no, ylog = no
logarithmic intervals?  If "yes" the output pixel intervals are logarithmic.
.le
.ls logfiles = "STDOUT,logfile"
List of files in which to keep a log.  If null, "", then no log is kept.
.le
.ih
DESCRIPTION
The coordinate maps U(X,Y) and V(X,Y), created by the task \fBfitcoords\fR,
are read from the database.  X and Y are the original untransformed
coordinates and U and V are desired output user coordinates (i.e. slit
position and wavelength).  If no coordinate map for one of the user coordinates
is given then a one-to-one mapping is assumed such that U=X or V=Y.
The coordinate maps are inverted to obtain X(U,V) and Y(U,V) on an even
subsampled grid of U and V over the desired output image coordinates.
The X and Y at each output U and V used to interpolate from the input
image are found by linear interpolation over this grid.  X(U,V) and Y(U,V)
are not determined at every output point because this is quite slow and
is not necessary since the coordinate surfaces are relatively slowly
varying over the subsampling (every 10th output point).

The type of image interpolation is
selected by the user.  Note that the more accurate the interpolator the
longer the transformation time required.  The parameter \fIflux\fR selects
between direct image interpolation and a flux conserving interpolation.
Flux conservation consists of multiplying the interpolated pixel value by
the Jacobean of the transformation at that point.  This is essentially
the ratio of the pixel areas between the output and input images.  Note
that this is not exact since it is not an integral over the output pixel.
However, it will be very close except when the output pixel size is much
greater than the input pixel size.  A log describing the image transformations
may be kept or printed on the standard output.

The output coordinate grid may be defined by the user or allowed to
default to an image of the same size as the input image spanning the
full range of user coordinates in the coordinate transformation maps.
When the coordinate maps are created by the task \fBfitcoords\fR the
user coordinates at the corners of the image are recorded in the
database.  By default these values are used to set the limits of the
output grid.  If a pixel interval is not specified then an interval
yielding the specified number of pixels is used.  The default number of
pixels is that of the input image.  Note that if a pixel interval is
specified then it takes precedence over the number of pixels.

The pixel intervals may also be logarithmic if the parameter \fIxlog\fR or
\fIylog\fR is "yes".  Generally, the number of output pixels is specified
in this case .  However, if the interval is specified it must be a base
10 logarithmic interval and not in units of the x and y limits which are
specified in user units.
.ih
EXAMPLES
Arc calibration images were used to determine a two dimensional dispersion
map called dispmap.  Stellar spectra were used to determine a two dimensional
distortion map call distort.  These maps where made using the task
\fBfitcoords\fR. To transform a set of input images into linear wavelength
between 3800 and 6400 Angstroms (the user coordinate units) with a dispersion
of 3 Angstroms per pixel:

.nf
	cl> transform obj001,obj002 out001,out002 dispmap,distort \
	>>> y1=3800 y2=6400 dy=3
.fi

To use logarithmic intervals in the wavelength to yield the same number of
pixels in the output images as in the input images:

.nf
	cl> transform obj001,obj002 out001,out002 dispmap,distort \
	>>> y1=3800 y2=6400 ylog=yes
.fi
.ih
TIMINGS
The following timings were obtained for transforming a 511x512 real
image to another 511x512 real image using two Chebyshev transformation
surface functions (one for the dispersion axis, "henear", and one in
spatial axis, "object") of order 6 in both dimensions created with the
task \fBfitcoords\fR.  The times are for a UNIX/VAX 11/750.

.nf
cl> $transform input output henear,object interp=linear
TIME (transform)  173.73  5:13  55%
cl> $transform input output henear,object interp=poly3
TIME (transform)  266.63  9:17  42%
cl> $transform input output henear,object interp=spline3
TIME (transform)  309.05  6:11  83%
cl> $transform input output henear,object interp=spline3
TIME (transform)  444.13  9:44  76%
cl> $transform input output henear interp=linear
TIME (transform)  171.32  7:24  38%
cl> $transform input output henear interp=spline3
TIME (transform)  303.40  12:17  41%
cl> $transform input output henear,object interp=spline3 flux=no
TIME (transform)  262.42  10:42  40%
.fi

The majority of the time is due to the image interpolation and not evaluating
the transformation functions as indicated by the last three examples.
.ih
NOTES
With Version 2.6 of IRAF the algorithm used to invert the user
coordinate surfaces, U(X,Y) and V(X,Y) to X(U,V) and Y(U,V), has been
changed.  Previously surfaces of comparable order to the original
surfaces were fit to a grid of points, i.e. (U(X,Y), V(X,Y), X) and
(U(X,Y), V(X,Y), Y), with the same surface fitting routines used in
\fBfitcoords\fR to obtain the input user coordinate surfaces.  This
method of inversion worked well in all cases in which reasonable
distortions and dispersions were used.  It was selected because it was
relatively fast.  However, it cannot be proved to work in all cases; in
one instance in which an invalid surface was used the inversion was
actually much poorer than expected.  Therefore a more direct iterative
inversion algorithm is now used.  This is guarenteed to give the
correct inversion to within a set error (0.05 of a pixel in X and Y).
It is slightly slower than the previous algorithm but it is still not
as major a factor as the image interpolation itself.
.ih
SEE ALSO
fitcoords
.endhelp
