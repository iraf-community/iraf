include	<error.h>
include	<imhdr.h>
include	<math/iminterp.h>
include	"disptable.h"

# Maximum number of aperture list ranges.
define	NRANGES		100

# Interpolation types.
define	INTERP	"|linear|poly3|poly5|spline3|"
define	LINEAR		1
define	POLY3		2
define	POLY5		3
define	SPLINE3		4

# Dispersion inversion parameters.
define	NIT	10	# Max interations in determining dispersion inversion
define	DX	1.D-5	# Accuracy limit in pixels for dispersion inversion

# Output formats
define	FORMATS	"|onedspec|multispec|"
define	ONEDSPEC	1	# Individual spectra
define	MULTISPEC	2	# All spectra in one image

# T_DISPCOR -- Dispersion correct ONEDSPEC spectra.
# The input spectra are corrected to a linear (or logarithmically
# linear) wavelength scale.  The dispersion function is defined either
# from reference spectra specified by the image header parameters
# REFSPEC1 and REFSPEC2 or from linear wavelength if the spectra have
# been previously dispersion corrected.  The former requires that the
# specified reference spectra have dispersion function in the database
# generated by IDENTIFY.  The latter requires that the "rebin" flag
# be set.  The spectra may be subselected by aperture number.
# 
# The linear wavelength scale may be specfied by any combination of
# starting and ending wavelength, wavelength interval, and number of
# pixels.  Suitable defaults may be used from the limits of the
# dispersion solutions.  The wavelength scale may be set globally for all
# spectra, globally by aperture by using a wavelength table for the
# defaults, and individually.  The user may confirm and change the
# wavelength scale.
# 
# The spectra are interpolated using one of the standard image
# interpolation types and the flux may be conserved by integrating the
# interpolation function.

procedure t_dispcor ()

pointer	odrin			# List of input spectra
pointer	odrout			# List of output spectra
pointer	db			# Dispersion solution database
pointer	aps			# Aperture list
bool	apflag			# Ignore apertures in global defaults?
int	format			# Output format
bool	log			# Log scale?
bool	flux			# Conserve flux?

int	i, naps
pointer	sp, input, output, str, table
bool	clgetb()
int	odr_getim(), odr_len(), decode_ranges()

begin
	call smark (sp)
	call salloc (input, SZ_FNAME, TY_CHAR)
	call salloc (output, SZ_FNAME, TY_CHAR)
	call salloc (db, SZ_FNAME, TY_CHAR)
	call salloc (str, SZ_LINE, TY_CHAR)
	call salloc (aps, 3*NRANGES, TY_INT)

	# Task parameters
#	format = clgwrd ("format", Memc[str], SZ_LINE, FORMATS)
	format = ONEDSPEC
	switch (format) {
	case ONEDSPEC:
	    if (clgetb ("recformat"))
	        call odr_open2 ("input", "output", "records", odrin, odrout)
	    else
	        call odr_open2 ("input", "output", "", odrin, odrout)
	case MULTISPEC:
	    if (clgetb ("recformat"))
	        call odr_open1 ("input", "records", odrin)
	    else
	        call odr_open1 ("input", "", odrin)
	    call odr_open1 ("output", "", odrout)
	}
	call clgstr ("database", Memc[db], SZ_FNAME)
	call clgstr ("apertures", Memc[str], SZ_LINE)
	apflag = clgetb ("ignoreaps")
	log = clgetb ("log")
	flux = clgetb ("flux")

	# Expand the aperture list.
	if (decode_ranges (Memc[str], Memi[aps], NRANGES, i) == ERR)
	    call error (0, "Bad aperture list")

	# Initialize the database cacheing and wavelength table.
	call dc_open()
	call dc_table (table, naps)
	if (clgetb ("global"))
	    call dc_global (odrin, Memc[db], aps, apflag, log, table, naps)

	# Loop through each input image.  Do the dispersion correction
	# in place if no output spectrum list is given or fit the input
	# and output spectra names are the same.  The aperture selection
	# and image access check is done by DC_GSPEC.

	while (odr_getim (odrin, Memc[input], SZ_FNAME) != EOF) {
	    if (odr_len (odrout) > 0) {
		if (odr_getim (odrout, Memc[output], SZ_FNAME) == EOF)
		    break
	    } else
		call strcpy (Memc[input], Memc[output], SZ_FNAME)

	    switch (format) {
	    case ONEDSPEC:
	        call dc_dispcor (Memc[input], Memc[output], Memc[db], aps,
		    apflag, log, flux, table, naps)
	    case MULTISPEC:
	        call dc_multispec (odrin, odrout, Memc[db], aps, apflag, log,
		    flux, table, naps)
		break
	    }
	}

	# Finish up.
	do i = 0, naps
	    call mfree (Memi[table+i], TY_STRUCT)
	call mfree (table, TY_INT)
	call odr_close (odrin)
	call odr_close (odrout)
	call dc_close()
	call sfree (sp)
end


# DC_DISPCOR -- Dispersion correct spectrum.

procedure dc_dispcor (input, output, db, aps, apflag, log, flux, table, naps)

char	input[ARB]		# Input spectrum
char	output[ARB]		# Output spectrum
char	db[ARB]			# Database
pointer	aps			# Aperture list
bool	apflag			# Ignore aperture in global defaults?
bool	log			# Log wavelength parameters?
bool	flux			# Conserve flux?
pointer	table			# Wavelength table
int	naps			# Number of apertures

bool	rebin
int	i, ap, nw
real	w1, w2, dw
double	dc_eval()
pointer	sp, temp, in, out, indata, outdata
pointer	dc_gspec(), immap(), imgl2r(), impl2r()
bool	clgetb(), streq()
errchk	dc_gspec
extern  dc_eval

begin
	# Get the input spectrum.  Check aperture number if needed.
	in = dc_gspec (input, db, aps, apflag, ap, i)
	if (in == NULL)
	    return

	# Skip spectra that don't satisfy rebin flag.
	rebin = clgetb ("rebin")
	if ((rebin && i == -1) || (!rebin && i != -1)) {
	    call imunmap (in)
	    return
	}

	# Get the wavelength parameters and check for errors.
	call dc_wavelengths (in, output, log, table, naps, apflag,
	    ap, w1, w2, dw, nw)
	if ((dw*(w2-w1) <= 0.) || (nw < 1)) {
	    call eprintf ("Error in wavelength scale")
	    call imunmap (in)
	    return
	}

	if (clgetb ("listonly")) {
	    call imunmap (in)
	    return
	}

	call smark (sp)
	call salloc (temp, SZ_FNAME, TY_CHAR)

	# If the output name is the same as the input name use a temp spec.
	if (streq (input, output)) {
	    call mktemp ("temp", Memc[temp], SZ_LINE)
	    iferr (out = immap (Memc[temp], NEW_COPY, in)) {
	        call imunmap (in)
		call sfree (sp)
	        call erract (EA_WARN)
	        return
	    }
	} else {
	    iferr (out = immap (output, NEW_COPY, in)) {
	        call imunmap (in)
		call sfree (sp)
	        call erract (EA_WARN)
	        return
	    }
	}
	if (IM_PIXTYPE(out) == TY_SHORT)
	    IM_PIXTYPE(out) = TY_REAL
	IM_LEN(out,1) = nw

	# Now do the dispersion correction and create the output
	# spectrum.  Add header keywords.

	do i = 1, IM_LEN(in,2) {
	    indata = imgl2r (in,i)
	    outdata = impl2r (out,i)
	    call aclrr (Memr[outdata], IM_LEN(out,1))
	    call dispcor (Memr[indata], IM_LEN(in,1), Memr[outdata],
	        w1, dw, nw, log, flux, dc_eval)
	}
	call imaddr (out, "CRPIX1", 1.)
	call imaddr (out, "CRVAL1", w1)
	call imaddr (out, "CDELT1", dw)
	call imaddr (out, "CD1_1", dw)
	call imaddr (out, "W0", w1)
	call imaddr (out, "WPC", dw)
	call imaddi (out, "NP1", 0)
	call imaddi (out, "NP2", nw)
	if (log)
	    call imaddi (out, "DC-FLAG", 1)
	else
	    call imaddi (out, "DC-FLAG", 0)

	# Finish up.  Replace input by output if needed.
	call imunmap (in)
	call imunmap (out)
	if (streq (input, output)) {
	    call imdelete (input)
	    call imrename (Memc[temp], output)
	}

	call sfree (sp)
end


# DC_MULTISPEC -- Linearize spectra to an output MULTISPEC format.

procedure dc_multispec (odrin, odrout, db, aps, apflag, log, flux, table, naps)

pointer	odrin		# Input list
pointer	odrout		# Output list
char	db[ARB]		# Database
pointer	aps		# Aperture list
bool	apflag		# Ignore aperture in global defaults?
bool	log		# Log wavelength parameters?
bool	flux		# Conserve flux?
pointer	table		# Wavelength table
int	naps		# Number of apertures

bool	rebin
int	i, nc, nl, nwmax, odr_len(), odr_getim()
pointer	sp, input, output, str, str1, ap, w1, w2, dw, nw, npts, data
pointer	in, out, indata, outdata
pointer	dc_gspec(), immap(), imgl1r(), impl2r()
bool	clgetb()
double	dc_eval()
extern  dc_eval
errchk	dc_gspec

begin
	nl = odr_len (in)

	call smark (sp)
	call salloc (input, SZ_FNAME, TY_CHAR)
	call salloc (output, SZ_FNAME, TY_CHAR)
	call salloc (str, SZ_LINE, TY_CHAR)
	call salloc (str1, SZ_LINE, TY_CHAR)
	call salloc (ap, nl, TY_INT)
	call salloc (w1, nl, TY_REAL)
	call salloc (w2, nl, TY_REAL)
	call salloc (dw, nl, TY_REAL)
	call salloc (nw, nl, TY_INT)
	call salloc (npts, nl, TY_INT)
	call salloc (data, nl, TY_INT)

	rebin = clgetb ("rebin")

	nwmax = 0
	nl = 0
	call odr_rew (odrin)
	call odr_rew (odrout)
	while (odr_getim (odrin, Memc[input], SZ_FNAME) != EOF) {
	    in = dc_gspec (Memc[input], db, aps, apflag, Memi[ap+nl], i)
	    if (in == NULL)
	        next

	    # Skip spectra that don't satisfy rebin flag.
	    if ((rebin && i == -1) || (!rebin && i != -1)) {
	        call imunmap (in)
	        next
	    }

	    if (nl == 0) {
	        i = odr_getim (odrout, Memc[output], SZ_FNAME)

	        iferr (out = immap (Memc[output], NEW_COPY, in)) {
		    call imunmap (in)
		    call erract (EA_WARN)
		    break
	        }
	    }

	    call dc_wavelengths (in, Memc[input], log, table, naps, apflag,
		Memi[ap+nl], Memr[w1+nl], Memr[w2+nl], Memr[dw+nl], Memi[nw+nl])
	    nwmax = max (nwmax, Memi[nw+i-1])

	    if ((Memr[dw+nl]*(Memr[w2+nl]-Memr[w1+nl]) <= 0.) ||
		(Memi[nw+nl] < 1)) {
	        call eprintf ("Error in wavelength scale")
	        call imunmap (in)
	        call imunmap (out)
		break
	    }

	    if (clgetb ("listonly")) {
		call imunmap (in)
		next
	    }

	    nc = IM_LEN (in,1)
	    call salloc (indata, nc, TY_REAL)
	    Memi[npts+nl] = nc
	    Memi[data+nl] = indata
	    call amovr (Memc[imgl1r(in)], Memr[indata], nc)
	    call imunmap (in)

	    nl = nl + 1
	}

	if (nl == 0) {
	    call sfree (sp)
	    return
	}

	IM_NDIM(out) = 2
	IM_LEN(out,1) = nwmax
	IM_LEN(out,2) = nl

	do i = 1, nl {
	    nc = Memi[npts+i-1]
	    indata = Memi[data+i-1]
	    outdata = impl2r (out,i)
	    call aclrr (Memr[outdata], IM_LEN(out,1))
	    call dispcor (Memr[indata], nc, Memr[outdata], Memr[w1+i-1],
		Memr[dw+i-1], Memi[nw+i-1], log, flux, dc_eval)

	    call imastr (out, "APFORMAT", "multispec")
	    call sprintf (Memc[str], SZ_LINE, "APNUM%d")
		call pargi (i)
	    call sprintf (Memc[str1], SZ_LINE, "%d %8g %8g %d")
		call pargi (Memi[ap+i-1])
		call pargr (Memr[w1+i-1])
		call pargr (Memr[dw+i-1])
		call pargr (Memi[nw+i-1])
	    call imastr (out, Memc[str], Memc[str1])
	}
	call imunmap (out)

	call sfree (sp)
end


# DC_GLOBAL -- Set global wavelength parameters.
# Go through each spectrum and determine the maximum wavelength limits
# and maximum number of pixels.  Use this to fill INDEF wavelength parameters.

procedure dc_global (odrin, db, aps, apflag, log, table, naps)

pointer	odrin		# Input list
char	db[ARB]		# Database
pointer	aps		# Aperture list
bool	apflag		# Ignore aperture in global defaults?
bool	log		# Logarithmic scale?
pointer	table		# Wavelength table
int	naps		# Number of apertures

int	i, nw, ap, odr_getim()
real	w1, w2
double	x, dc_eval()
pointer	sp, input, in, tbl, dc_gspec()
errchk	dc_gspec

begin
	call smark (sp)
	call salloc (input, SZ_FNAME, TY_CHAR)

	# Go through all the reference spectra and determine the
	# minimum and maximum wavelengths and maximum number of pixels.
	# Do this by aperture.  If there is no entry in the wavelength
	# table add it.

	while (odr_getim (odrin, Memc[input], SZ_FNAME) != EOF) {
	    in = dc_gspec (Memc[input], db, aps, apflag, ap, i)
	    if (in == NULL)
		next

	    call dc_getentry (apflag, ap, table, naps, i)
	    tbl = Memi[table+i]
			
	    nw = IM_LEN(in,1)
	    x = 1
	    w1 = dc_eval (x)
	    x = nw
	    w2 = dc_eval (x)
	    TBL_WMIN(tbl) = min (TBL_WMIN(tbl), w1, w2)
	    TBL_WMAX(tbl) = max (TBL_WMAX(tbl), w1, w2)
	    TBL_NWMAX(tbl) = max (TBL_NWMAX(tbl), nw)

	    call imunmap (in)
	}
	call odr_rew (odrin)

	do i = 1, naps {
	    tbl = Memi[table+i]
	    if (log) {
		TBL_WMIN(tbl) = log10 (TBL_WMIN(tbl))
		TBL_WMAX(tbl) = log10 (TBL_WMAX(tbl))
	    }
	    call dc_defaults (TBL_WMIN(tbl), TBL_WMAX(tbl), TBL_NWMAX(tbl),
		TBL_W1(tbl), TBL_W2(tbl), TBL_DW(tbl), TBL_NW(tbl))
	}

	call sfree (sp)
end


# DC_WAVELENGTHS -- Set output wavelength parameters for a spectrum.
# Replace INDEF parameters by suitable limits for the dispersion function.
# The user may confirm and change the wavelength parameters.

procedure dc_wavelengths (in, output, log, table, naps, apflag,
	ap, w1, w2, dw, nw)

pointer	in		# IMIO pointer
char	output[ARB]	# Output image name
bool	log		# Logarithm wavelength parameters?
pointer	table		# Wavelength table
int	naps		# Number of apertures
bool	apflag		# Ignore aperture number?
int	ap		# Aperture
real	w1, w2, dw	# Image wavelength parameters
int	nw		# Image wavelength parameter

int	i, n, clgeti(), clgwrd()
real	a, b, c, clgetr()
double	x, dc_eval()
bool	clgetb()
pointer	sp, ans, tbl

begin
	# Get aperture parameters.
	call dc_getentry (apflag, ap, table, naps, i)
	tbl = Memi[table+i]

	w1 = TBL_W1(tbl)
	w2 = TBL_W2(tbl)
	dw = TBL_DW(tbl)
	nw = TBL_NW(tbl)
	  
	# If there are undefined wavelength scale parameters get
	# defaults based on the reference spectrum.

	if (IS_INDEF(w1)||IS_INDEF(w2)||IS_INDEF(dw)||IS_INDEFI(nw)) {
	    n = IM_LEN(in,1)
	    x = 1
	    a = dc_eval (x)
	    x = n
	    b = dc_eval (x)
	    if (log) {
		a = log10 (a)
		b = log10 (b)
	    }
	}

	call dc_defaults (a, b, n, w1, w2, dw, nw)

	# Print the wavelength scale and allow the user to confirm and
	# change the wavelength scale.  A test is done to check which
	# parameters the user changes and give them priority in filling
	# in the remaining parameters.

	call printf ("%s: ap = %d, w1 = %g, w2 = %g, dw = %g, nw = %d\n")
	    call pargstr (output)
	    call pargi (ap)
	    call pargr (w1)
	    call pargr (w2)
	    call pargr (dw)
	    call pargi (nw)

	if (TBL_CONFIRM(tbl) == YES) {
	    call smark (sp)
	    call salloc (ans, SZ_LINE, TY_CHAR)
	    repeat {
		i = clgwrd ("dispcor1.change", Memc[ans],SZ_LINE, "|yes|no|NO|")
		switch (i) {
		case 2:
		    break
		case 3:
		    TBL_CONFIRM(tbl) = NO
		    break
		}
		call clputr ("dispcor1.w1", w1)
		call clputr ("dispcor1.w2", w2)
		call clputr ("dispcor1.dw", dw)
		call clputi ("dispcor1.nw", nw)
		a = w1
		b = w2
		c = dw
		n = nw
		w1 = clgetr ("dispcor1.w1")
		w2 = clgetr ("dispcor1.w2")
		dw = clgetr ("dispcor1.dw")
		nw = clgeti ("dispcor1.nw")
		i = 0
		if (IS_INDEF(w1))
		    i = i + 1
		if (IS_INDEF(w2))
		    i = i + 1
		if (IS_INDEF(dw))
		    i = i + 1
		if (IS_INDEFI(nw))
		    i = i + 1
		if (i == 0) {
		    if (w1 == a)
		        w1 = INDEF
		    if (w2 == b)
		        w2 = INDEF
		    if (dw == c)
		        dw = INDEF
		    if (nw == n)
		        nw = INDEFI
		}
	        call dc_defaults (a, b, n, w1, w2, dw, nw)

		call printf (
		    "%s: ap = %d, w1 = %g, w2 = %g, dw = %g, nw = %d\n")
		    call pargstr (output)
		    call pargi (ap)
		    call pargr (w1)
		    call pargr (w2)
		    call pargr (dw)
		    call pargi (nw)

		if (clgetb ("global")) {
		    TBL_W1(tbl) = w1
		    TBL_W2(tbl) = w2
		    TBL_DW(tbl) = dw
		    TBL_NW(tbl) = nw
		}
	    }
	    call sfree (sp)
	}
	call flush (STDOUT)
end


# DISPCOR -- Dispersion correct input spectrum to output spectrum.
# This procedure needs to invert the specified dispersion solutions
# and interpolate the input data, conserving flux if desired.  Image
# interpolation uses the image interpolation package and flux conservation
# integrates the interpolation function across the output pixel.  This
# procedure does some CLIO to get the interpolation function and to
# query whether to conserve flux.

procedure dispcor (in, npts, out, w1, dw, nw, log, flux, func)

real	in[npts]		# Input spectrum
int	npts			# Number of input pixels
real	out[nw]			# Output spectrum
real	w1			# Starting wavelength
real	dw			# Wavelength per pixel
int	nw			# Number of output pixels
bool	log			# Log scale?
bool	flux			# Conserve flux
double	func()			# Dispersion function

int	i, j, i1, i2, clgwrd()
real	a, b, asieval(), asigrl()
double	x, dx, xmin, xmax, xmin1, xmax1, y, dxdy, w, w1d, dwd
pointer	asi, sp, str, temp
extern	func

int	asitype[4]
data	asitype/II_LINEAR, II_POLY3, II_POLY5, II_SPLINE3/

begin
	call smark (sp)
	call salloc (str, SZ_LINE, TY_CHAR)

	# Determine approximate slope of dispersion function.
	xmin = 1
	xmax = npts
	xmin1 = xmin - 0.5
	xmax1 = xmax + 0.5
	w1d = w1
	dwd = dw
	x = func (xmin)
	y = func (xmax)
	if (log) {
	    i = (log10 (x) - w1d) / dwd + 1
	    j = (log10 (y) - w1d) / dwd + 1
	} else {
	    i = (x - w1d) / dwd + 1
	    j = (y - w1d) / dwd + 1
	}
	i1 = max (1, min (i, j) - 1)
	i2 = min (nw, max (i, j) + 1)
	dxdy = (xmax - xmin) / (y - x)

	# Initialize starting point.
	if (dwd * dxdy > 0.) {
	    y = x
	    x = 1
	} else
	    x = xmax

	# Get the image buffers, determine the interpolaion type, and
	# fit the interpolation function to the input spectrum.
	# Extend the interpolation by one pixel at each end.

	i = clgwrd ("interpolation", Memc[str], SZ_LINE, INTERP)
	call malloc (temp, npts+2, TY_REAL)
	call amovr (in, Memr[temp+1], npts)
	Memr[temp] = in[1]
	Memr[temp+npts+1] = in[npts]

	call asiinit (asi, asitype[i])
	call asifit (asi, Memr[temp], npts+2)

	call mfree (temp, TY_REAL)

	# If flux conserving determine edges of output pixels in input
	# spectrum and integrate using ASIGRL.  If not flux conserving
	# determine the center of each output pixel in the input spectrum
	# and evaluate the interpolation function with ASIEVAL.

	if (flux) {
	    # Determine initial left edge.
	    w = w1d + dwd * (i1 - 1.5)
	    if (log)
		w = 10. ** w
	    do j = 1, NIT {
	        x = max (xmin, min (xmax, x))
		y = func (x)
		dx = dxdy * (w - y)
		x = x + dx
	        if (abs (dx) < DX)
		    break
	    }
	    b = max (xmin1, min (xmax1, x)) + 1
	    do i = i1, i2 {
	        w = w1d + dwd * (i - 0.5)
	        if (log)
		    w = 10. ** w
	        do j = 1, NIT {
	            x = max (xmin, min (xmax, x))
		    y = func (x)
		    dx = dxdy * (w - y)
		    x = x + dx
	            if (abs (dx) < DX)
		        break
	        }
		a = b
	        b = max (xmin1, min (xmax1, x)) + 1
		if (a < b)
		    out[i] = asigrl (asi, a, b)
		else
		    out[i] = asigrl (asi, b, a)
	    }
	} else {
	    do i = i1, i2 {
	        w = w1d + dwd * (i - 1)
		if (log)
		    w = 10. ** w
	        do j = 1, NIT {
	            x = max (xmin, min (xmax, x))
		    y = func (x)
		    dx = dxdy * (w - y)
		    x = x + dx
	            if (abs (dx) < DX)
		        break
	        }

		if ((x >= xmin1) && (x <= xmax1)) {
		    a = x + 1
	            out[i] = asieval (asi, a)
		} else
	            out[i] = 0.
	    }
	}

	call asifree (asi)
	call sfree (sp)
end


# DC_DEFAULTS -- Given some set of wavelength scale with others undefined
# (INDEF) plus some defaults fill in the undefined parameters and make
# the wavelength scale consistent.  The logic of this task is complex
# and is meant to provide an "intelligent" result based on what users
# want.

procedure dc_defaults (a, b, n, w1, w2, dw, nw)

real	a		# Default wavelength endpoint
real	b		# Default wavelength endpoint
int	n		# Default number of pixels
real	w1		# Starting wavelength
real	w2		# Ending wavelength
real	dw		# Wavelength interval
int	nw		# Number of pixels

int	nindef

begin
	# Determine how many input parameters are specfied.
	nindef = 0
	if (IS_INDEF(w1))
	    nindef = nindef + 1
	if (IS_INDEF(w2))
	    nindef = nindef + 1
	if (IS_INDEF(dw))
	    nindef = nindef + 1
	if (IS_INDEFI(nw))
	    nindef = nindef + 1

	# Depending on how many parameters are specified fill in the
	# INDEF parameters.

	switch (nindef) {
	case 0:
	    # All parameters specified.  First round NW to be consistent with
	    # w1, w2, and dw.  Then adjust w2 to nearest pixel.  It is possible
	    # that nw will be negative.  Checks for this should be made by the
	    # call in program.

	    nw = (w2 - w1) / dw + 1.5
	    w2 = w1 + dw * (nw - 1)
	case 1:
	    # Find the unspecified parameter and compute it from the other
	    # three specified parameters.  For nw need to adjust w2 to
	    # agree with a pixel.

	    if (IS_INDEF(w1))
		w1 = w2 - dw * (nw - 1)
	    if (IS_INDEF(w2))
		w2 = w1 + dw * (nw - 1)
	    if (IS_INDEF(dw))
		dw = (w2 - w1) / (nw - 1)
	    if (IS_INDEFI(nw)) {
	        nw = (w2 - w1) / dw + 1.5
		w2 = w1 + dw * (nw - 1)
	    }
	case 2:
	    # Fill in two unspecified parameters using the defaults.
	    # This is tricky.

	    if (IS_INDEF(dw)) {
		if (IS_INDEF(w1)) {
		    if (abs (w2 - a) > abs (w2 - b))
			w1 = a
		    else
			w1 = b
		    dw = (w2 - w1) / (nw - 1)
		} else if (IS_INDEF(w2)) {
		    if (abs (w1 - a) > abs (w1 - b))
			w2 = a
		    else
			w2 = b
		    dw = (w2 - w1) / (nw - 1)
		} else {
		    dw = (b - a) / n
		    nw = abs ((w2 - w1) / dw) + 1.5
		    dw = (w2 - w1) / (nw - 1)
		}
	    } else if (IS_INDEFI(nw)) {
		if (IS_INDEF(w1)) {
		    if (dw > 0.)
			w1 = min (a, b)
		    else
			w1 = max (a, b)
		    nw = (w2 - w1) / dw + 1.5
		    w1 = w2 - dw * (nw - 1)
		} else {
		    if (dw > 0.)
			w2 = max (a, b)
		    else
			w2 = min (a, b)
		    nw = (w2 - w1) / dw + 1.5
		    w2 = w1 + dw * (nw - 1)
		}
	    } else {
		if (dw > 0.)
		    w1 = min (a, b)
		else
		    w1 = max (a, b)
		w2 = w1 + dw * (nw - 1)
	    }
	case 3:
	    # Find the one specfied parameter and compute the others using
	    # the supplied defaults.

	    if (!IS_INDEF(w1)) {
		if (abs (w1 - a) > abs (w1 - b))
		    w2 = a
		else
		    w2 = b
		dw = (b - a) / n
		nw = abs ((w2 - w1) / dw) + 1.5
		dw = (w2 - w1) / (nw - 1)
	    } else if (!IS_INDEF(w2)) {
		if (abs (w2 - a) > abs (w2 - b))
		    w1 = a
		else
		    w1 = b
		dw = (b - a) / n
		nw = abs ((w2 - w1) / dw) + 1.5
		dw = (w2 - w1) / (nw - 1)
	    } else if (!IS_INDEFI(nw)) {
		w1 = min (a, b)
		w2 = max (a, b)
	        dw = (w2 - w1) / (nw - 1)
	    } else if (dw < 0.) {
		w1 = max (a, b)
		w2 = min (a, b)
		nw = (w2 - w1) / dw + 1.5
		w2 = w1 + dw * (nw - 1)
	    } else {
		w1 = min (a, b)
		w2 = max (a, b)
		nw = (w2 - w1) / dw + 1.5
		w2 = w1 + dw * (nw - 1)
	    }
	case 4:
	    # Given only defaults compute a wavelength scale.  The dispersion
	    # is kept close to the default.
	    w1 = min (a, b)
	    w2 = max (a, b)
	    dw = (b - a) / (n - 1)
	    nw = abs ((w2 - w1) / dw) + 1.5
	    dw = (w2 - w1) / (nw - 1)
	}
end
